var Ga = Object.defineProperty;
var Ua = (e, t, a) => t in e ? Ga(e, t, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[t] = a;
var le = (e, t, a) => (Ua(e, typeof t != "symbol" ? t + "" : t, a), a);
import { computed as u, reactive as ye, inject as Be, onMounted as de, onBeforeUnmount as bt, Comment as Wa, ref as G, toRef as s, onActivated as mt, watch as ie, nextTick as Se, defineComponent as C, provide as Fe, openBlock as c, createElementBlock as b, unref as o, normalizeClass as x, renderSlot as $, createBlock as N, resolveDynamicComponent as q, withCtx as L, createElementVNode as E, withDirectives as Pe, createTextVNode as Q, toDisplayString as H, createVNode as ge, createCommentVNode as P, normalizeStyle as _e, useSlots as Te, mergeProps as D, getCurrentInstance as Xa, Fragment as X, renderList as te, resolveComponent as We, isReactive as Ka, h as W, useAttrs as Pt, withModifiers as Et, isRef as Ee, vModelCheckbox as Ja, vModelRadio as Ya, vModelSelect as Za, normalizeProps as Oe, guardReactiveProps as Ne, Teleport as Qa, createSlots as el, Transition as tl, onUnmounted as al } from "vue";
import { Collapse as ll, Alert as nl, Carousel as sl, Dropdown as ol, Modal as il, Popover as st, Tooltip as Qe, Offcanvas as rl } from "bootstrap";
const ul = (e) => u(
  () => e.value === "center" ? "justify-content-center" : e.value === "end" ? "justify-content-end" : "justify-content-start"
), Ht = Symbol(), qt = {
  items: ye([]),
  reset() {
    this.items = ye([]);
  }
}, dl = (e) => {
  e.provide(Ht, qt);
}, cl = () => {
  const e = Be(Ht);
  return e || qt;
}, ae = (e, t, a) => {
  de(() => {
    var l;
    (l = e == null ? void 0 : e.value) == null || l.addEventListener(t, a);
  }), bt(() => {
    var l;
    (l = e == null ? void 0 : e.value) == null || l.removeEventListener(t, a);
  });
}, fl = (e, t) => e.indexOf(t) !== -1, vl = (...e) => Array.from([...e]), bl = (...e) => Array.prototype.concat.apply([], e);
class Xe {
  constructor(t, a = {}) {
    le(this, "cancelable", !0);
    le(this, "componentId", null);
    le(this, "defaultPrevented", !1);
    le(this, "nativeEvent", null);
    le(this, "preventDefault");
    le(this, "relatedTarget", null);
    le(this, "target", null);
    le(this, "eventType", "");
    le(this, "vueTarget", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    zl(this, Xe.Defaults, this.constructor.Defaults, a, { eventType: t }), Ll(this, {
      type: ke(),
      cancelable: ke(),
      nativeEvent: ke(),
      target: ke(),
      relatedTarget: ke(),
      vueTarget: ke(),
      componentId: ke()
    });
    let l = !1;
    this.preventDefault = function() {
      this.cancelable && (l = !0);
    }, Pl(this, "defaultPrevented", {
      enumerable: !0,
      get() {
        return l;
      }
    });
  }
  static get Defaults() {
    return {
      eventType: "",
      cancelable: !0,
      nativeEvent: null,
      target: null,
      relatedTarget: null,
      vueTarget: null,
      componentId: null
    };
  }
}
const et = (e) => `\\${e}`, ml = (e) => {
  e = it(e);
  const { length: t } = e, a = e.charCodeAt(0);
  return e.split("").reduce((l, n, r) => {
    const d = e.charCodeAt(r);
    return d === 0 ? `${l}\uFFFD` : d === 127 || d >= 1 && d <= 31 || r === 0 && d >= 48 && d <= 57 || r === 1 && d >= 48 && d <= 57 && a === 45 ? l + et(`${d.toString(16)} `) : r === 0 && d === 45 && t === 1 ? l + et(n) : d >= 128 || d === 45 || d === 95 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122 ? l + n : l + et(n);
  }, "");
}, Rt = typeof window < "u", jt = typeof document < "u", gl = typeof navigator < "u", pl = Rt && jt && gl, Dt = jt ? document : {}, $e = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), hl = (e) => $e(e) ? e.getBoundingClientRect() : null, yl = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((a) => a === t) ? t : null;
}, Bl = (e) => $e(e) && e === yl(), $l = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (a) {
    console.error(a);
  }
  return Bl(e);
}, kl = (e, t) => t && $e(e) && e.getAttribute(t) || null, Sl = (e) => {
  if (kl(e, "display") === "none")
    return !1;
  const t = hl(e);
  return !!(t && t.height > 0 && t.width > 0);
}, kt = (e, t) => !e || e(t).filter((a) => a.type !== Wa).length < 1, Tl = (e, t) => ($e(t) ? t : Dt).querySelector(e) || null, Cl = (e, t) => vl(($e(t) ? t : Dt).querySelectorAll(e)), Mt = (e, t) => t && $e(e) ? e.getAttribute(t) : null, Vl = (e, t, a) => {
  t && $e(e) && e.setAttribute(t, a);
}, wl = (e, t) => {
  t && $e(e) && e.removeAttribute(t);
}, _l = (e, t) => it(e).toLowerCase() === it(t).toLowerCase(), qe = Rt ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || ((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0), Ke = (e, t, a) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((l, n) => (l[e ? `${e}${n.charAt(0).toUpperCase() + n.slice(1)}` : n] = a, l), /* @__PURE__ */ Object.create(null)), Gt = (e, t, a, l = a) => Object.keys(t).reduce((n, r) => (e[r] && n.push(
  [l, r.replace(a, ""), e[r]].filter((d) => d && typeof d != "boolean").join("-").toLowerCase()
), n), []), he = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, Je = (e, t) => e === !0 || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === !1 ? "true" : e === !1 || e === "false" ? "false" : e, Al = /^[0-9]*\.?[0-9]+$/, tt = (e) => Xt(e) === "boolean", xl = (e) => e !== null && typeof e == "object", Ae = (e) => typeof e == "string", Fl = (e) => e === void 0, Il = (e) => e === null, Ut = (e) => Fl(e) || Il(e), Wt = (e) => Al.test(String(e)), Ol = (e) => typeof e == "number", Xt = (e) => typeof e, Kt = (e) => Xt(e) === "function", Jt = (e) => Object.prototype.toString.call(e) === "[object Object]", Yt = (e) => Array.isArray(e), at = (e) => e && typeof e == "object" && e.constructor === Object, ot = (e, t, a = !0) => {
  const l = e instanceof Date && typeof e.getMonth == "function" ? new Date(e) : Object.assign({}, e);
  return at(e) && at(t) && Object.keys(t).forEach((n) => {
    at(t[n]) ? n in e ? l[n] = ot(e[n], t[n], a) : Object.assign(l, { [n]: t[n] }) : Array.isArray(t[n]) && Array.isArray(e[n]) ? Object.assign(l, {
      [n]: a ? e[n].concat(t[n].filter((r) => !e[n].includes(r))) : t[n]
    }) : Object.assign(l, { [n]: t[n] });
  }), l;
}, ve = (e, t = {}, a = {}) => {
  const l = [e];
  let n;
  for (let r = 0; r < l.length && !n; r++) {
    const d = l[r];
    n = a[d];
  }
  return n && Kt(n) ? n(t) : n;
}, xe = (e, t = NaN) => Number.isInteger(e) ? e : t, Nl = (e, t = NaN) => {
  const a = parseInt(e, 10);
  return isNaN(a) ? t : a;
}, gt = (e, t = NaN) => {
  const a = parseFloat(e.toString());
  return isNaN(a) ? t : a;
}, zl = (e, ...t) => Object.assign(e, ...t), Ll = (e, t) => Object.defineProperties(e, t), Pl = (e, t, a) => Object.defineProperty(e, t, a), Ye = (e, t) => Object.keys(e).filter((a) => t.indexOf(a) === -1).reduce((a, l) => ({ ...a, [l]: e[l] }), {}), ke = () => ({ enumerable: !0, configurable: !1, writable: !1 }), St = (e, t) => t + (e ? Ml(e) : ""), Zt = (e, t, a = (l) => l) => (Yt(e) ? e.slice() : Object.keys(e)).reduce(
  (l, n) => (l[a(n)] = t[n], l),
  {}
), El = (e) => typeof e == "boolean" ? e : e === "" ? !0 : e === "true", ze = (e) => !!(e.href || e.to), Hl = /_/g, ql = /([a-z])([A-Z])/g, Rl = /(\s|^)(\w)/, Re = /\s+/, jl = /^#/, Dl = /^#[A-Za-z]+[\w\-:.]*$/, it = (e, t = 2) => Ut(e) ? "" : Yt(e) || Jt(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), Tt = (e) => e.replace(Hl, " ").replace(ql, (t, a, l) => `${a} ${l}`).replace(Rl, (t, a, l) => a + l.toUpperCase()), Ml = (e) => (e = Ae(e) ? e.trim() : String(e), e.charAt(0).toUpperCase() + e.slice(1)), Qt = (e) => u(() => ({
  "form-check": !e.plain && !e.button,
  "form-check-inline": e.inline,
  "form-switch": e.switch,
  [`form-control-${e.size}`]: e.size && e.size !== "md"
})), ea = (e) => u(() => ({
  "form-check-input": !e.plain && !e.button,
  "is-valid": e.state === !0,
  "is-invalid": e.state === !1,
  "btn-check": e.button
})), ta = (e) => u(() => ({
  "form-check-label": !e.plain && !e.button,
  btn: e.button,
  [`btn-${e.buttonVariant}`]: e.button,
  [`btn-${e.size}`]: e.button && e.size && e.size !== "md"
})), aa = (e) => u(() => {
  var t;
  return {
    "aria-invalid": Je(e.ariaInvalid, e.state),
    "aria-required": ((t = e.required) == null ? void 0 : t.toString()) === "true" ? "true" : null
  };
}), la = (e) => u(() => ({
  "was-validated": e.validated,
  "btn-group": e.buttons && !e.stacked,
  "btn-group-vertical": e.stacked,
  [`btn-group-${e.size}`]: e.size
})), Ge = (e, t, a) => e.filter((l) => l.type.name === t).map((l) => {
  const n = (l.children.default ? l.children.default() : []).find(
    (r) => r.type.toString() === "Symbol(Text)"
  );
  return {
    props: {
      disabled: a,
      ...l.props
    },
    text: n ? n.children : ""
  };
}), na = (e, t) => typeof e == "string" ? {
  props: {
    value: e,
    disabled: t.disabled
  },
  text: e
} : {
  props: {
    value: e[t.valueField],
    disabled: t.disabled || e[t.disabledField],
    ...e.props
  },
  text: e[t.textField],
  html: e[t.htmlField]
}, sa = (e, t, a, l, n) => ({
  ...e,
  props: {
    "button-variant": a.buttonVariant,
    form: a.form,
    name: l.value,
    id: `${n.value}_option_${t}`,
    button: a.buttons,
    state: a.state,
    plain: a.plain,
    size: a.size,
    inline: !a.stacked,
    required: a.required,
    ...e.props
  }
}), ce = (e, t) => u(() => (e == null ? void 0 : e.value) || he(t)), oa = {
  ariaInvalid: {
    type: [Boolean, String],
    default: void 0
  },
  autocomplete: { type: String, required: !1 },
  autofocus: { type: Boolean, default: !1 },
  disabled: { type: Boolean, default: !1 },
  form: { type: String, required: !1 },
  formatter: { type: Function, required: !1 },
  id: { type: String, required: !1 },
  lazy: { type: Boolean, default: !1 },
  lazyFormatter: { type: Boolean, default: !1 },
  list: { type: String, required: !1 },
  modelValue: { type: [String, Number], default: "" },
  name: { type: String, required: !1 },
  number: { type: Boolean, default: !1 },
  placeholder: { type: String, required: !1 },
  plaintext: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  required: { type: Boolean, default: !1 },
  size: { type: String, required: !1 },
  state: { type: Boolean, default: null },
  trim: { type: Boolean, default: !1 }
}, ia = (e, t) => {
  const a = G();
  let l = null, n = !0;
  const r = ce(s(e, "id"), "input"), d = (p, f, m = !1) => (p = String(p), typeof e.formatter == "function" && (!e.lazyFormatter || m) ? (n = !1, e.formatter(p, f)) : p), v = (p) => e.trim ? p.trim() : e.number ? parseFloat(p) : p, g = () => {
    Se(() => {
      var p;
      e.autofocus && ((p = a.value) == null || p.focus());
    });
  };
  de(g), de(() => {
    a.value && (a.value.value = e.modelValue);
  }), mt(g);
  const B = u(
    () => {
      var p;
      return Je(e.ariaInvalid, (p = e.state) != null ? p : void 0);
    }
  ), y = (p) => {
    const { value: f } = p.target, m = d(f, p);
    if (m === !1 || p.defaultPrevented) {
      p.preventDefault();
      return;
    }
    if (e.lazy)
      return;
    t("input", m);
    const I = v(m);
    e.modelValue !== I && (l = f, t("update:modelValue", I));
  }, h = (p) => {
    const { value: f } = p.target, m = d(f, p);
    if (m === !1 || p.defaultPrevented) {
      p.preventDefault();
      return;
    }
    if (!e.lazy)
      return;
    l = f, t("update:modelValue", m);
    const I = v(m);
    e.modelValue !== I && t("change", m);
  }, T = (p) => {
    if (t("blur", p), !e.lazy && !e.lazyFormatter)
      return;
    const { value: f } = p.target, m = d(f, p, !0);
    l = f, t("update:modelValue", m);
  }, V = () => {
    var p;
    e.disabled || (p = a.value) == null || p.focus();
  }, k = () => {
    var p;
    e.disabled || (p = a.value) == null || p.blur();
  };
  return ie(
    () => e.modelValue,
    (p) => {
      !a.value || (a.value.value = l && n ? l : p, l = null, n = !0);
    }
  ), {
    input: a,
    computedId: r,
    computedAriaInvalid: B,
    onInput: y,
    onChange: h,
    onBlur: T,
    focus: V,
    blur: k
  };
}, we = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const a = t.split(".");
  return we(e[a[0]], a.splice(1).join("."));
}, lt = (e, t = null, a, l) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const n = we(e, l.valueField), r = we(e, l.textField), d = we(e, l.htmlField), v = we(e, l.disabledField), g = e[l.optionsField] || null;
    return g !== null ? {
      label: String(we(e, l.labelField) || r),
      options: pt(g, a, l)
    } : {
      value: typeof n > "u" ? t || r : n,
      text: String(typeof r > "u" ? t : r),
      html: d,
      disabled: Boolean(v)
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: !1
  };
}, pt = (e, t, a) => Array.isArray(e) ? e.map((l) => lt(l, null, t, a)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((l) => {
  const n = e[l];
  switch (typeof n) {
    case "object":
      return lt(n.text, String(n.value), t, a);
    default:
      return lt(n, String(l), t, a);
  }
})) : [], i = (e) => u(() => El(e.value)), Gl = ["id"], ra = Symbol(), Ul = /* @__PURE__ */ C({
  __name: "BAccordion",
  props: {
    flush: { default: !1 },
    free: { default: !1 },
    id: { default: void 0 }
  },
  setup(e) {
    const t = e, a = ce(s(t, "id"), "accordion"), l = i(s(t, "flush")), n = i(s(t, "free")), r = u(() => ({
      "accordion-flush": l.value
    }));
    return n.value || Fe(ra, a.value.toString()), (d, v) => (c(), b("div", {
      id: o(a),
      class: x(["accordion", o(r)])
    }, [
      $(d.$slots, "default")
    ], 10, Gl));
  }
}), ua = /* @__PURE__ */ C({
  __name: "BCollapse",
  props: {
    accordion: null,
    id: { default: he() },
    modelValue: { default: !1 },
    tag: { default: "div" },
    toggle: { default: !1 },
    visible: { default: !1 },
    isNav: { default: !1 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "modelValue")), n = i(s(a, "toggle")), r = i(s(a, "visible")), d = i(s(a, "isNav")), v = G(), g = G(), B = u(() => ({
      show: l.value,
      "navbar-collapse": d.value
    })), y = () => t("update:modelValue", !1);
    return ae(v, "show.bs.collapse", () => {
      t("show"), t("update:modelValue", !0);
    }), ae(v, "hide.bs.collapse", () => {
      t("hide"), t("update:modelValue", !1);
    }), ae(v, "shown.bs.collapse", () => t("shown")), ae(v, "hidden.bs.collapse", () => t("hidden")), de(() => {
      var h;
      g.value = new ll(v.value, {
        parent: a.accordion ? `#${a.accordion}` : void 0,
        toggle: n.value
      }), (r.value || l.value) && (t("update:modelValue", !0), (h = g.value) == null || h.show());
    }), ie(
      () => l.value,
      (h) => {
        var T, V;
        h ? (T = g.value) == null || T.show() : (V = g.value) == null || V.hide();
      }
    ), ie(
      () => r.value,
      (h) => {
        var T, V;
        h ? (t("update:modelValue", !!h), (T = g.value) == null || T.show()) : (t("update:modelValue", !!h), (V = g.value) == null || V.hide());
      }
    ), (h, T) => (c(), N(q(e.tag), {
      id: e.id,
      ref_key: "element",
      ref: v,
      class: x(["collapse", o(B)]),
      "data-bs-parent": e.accordion || null,
      "is-nav": o(d)
    }, {
      default: L(() => [
        $(h.$slots, "default", {
          visible: o(l),
          close: y
        })
      ]),
      _: 3
    }, 8, ["id", "class", "data-bs-parent", "is-nav"]));
  }
}), Wl = (e) => {
  if (e.classList.contains("offcanvas"))
    return "offcanvas";
  if (e.classList.contains("collapse"))
    return "collapse";
  throw Error("Couldn't resolve toggle type");
}, Xl = (e, t) => {
  const { modifiers: a, arg: l, value: n } = e, r = Object.keys(a || {}), d = Ae(n) ? n.split(Re) : n;
  if (_l(t.tagName, "a")) {
    const v = Mt(t, "href") || "";
    Dl.test(v) && r.push(v.replace(jl, ""));
  }
  return bl(l, d).forEach((v) => Ae(v) && r.push(v)), r.filter((v, g, B) => v && B.indexOf(v) === g);
}, ht = {
  mounted(e, t) {
    const a = Xl(t, e), l = [];
    let n = "data-bs-target";
    e.tagName === "a" && (n = "href");
    for (let r = 0; r < a.length; r++) {
      const d = a[r], v = document.getElementById(d);
      v && (e.setAttribute("data-bs-toggle", Wl(v)), l.push(`#${d}`));
    }
    l.length > 0 && e.setAttribute(n, l.join(","));
  }
}, Kl = { class: "accordion-item" }, Jl = ["id"], Yl = ["aria-expanded", "aria-controls"], Zl = { class: "accordion-body" }, Ql = /* @__PURE__ */ C({
  __name: "BAccordionItem",
  props: {
    id: null,
    title: null,
    visible: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(s(t, "visible")), l = ce(s(t, "id"), "accordion_item"), n = Be(ra, "");
    return (r, d) => (c(), b("div", Kl, [
      E("h2", {
        id: `${o(l)}heading`,
        class: "accordion-header"
      }, [
        Pe((c(), b("button", {
          class: x(["accordion-button", { collapsed: !o(a) }]),
          type: "button",
          "aria-expanded": o(a) ? "true" : "false",
          "aria-controls": o(l)
        }, [
          $(r.$slots, "title", {}, () => [
            Q(H(e.title), 1)
          ])
        ], 10, Yl)), [
          [o(ht), void 0, o(l)]
        ])
      ], 8, Jl),
      ge(ua, {
        id: o(l),
        class: "accordion-collapse",
        visible: o(a),
        accordion: o(n),
        "aria-labelledby": `heading${o(l)}`
      }, {
        default: L(() => [
          E("div", Zl, [
            $(r.$slots, "default")
          ])
        ]),
        _: 3
      }, 8, ["id", "visible", "accordion", "aria-labelledby"])
    ]));
  }
}), en = ["aria-label"], tn = /* @__PURE__ */ C({
  __name: "BAlert",
  props: {
    dismissLabel: { default: "Close" },
    dismissible: { default: !1 },
    fade: { default: !1 },
    modelValue: { type: [Boolean, Number], default: !1 },
    show: { default: !1 },
    variant: { default: "info" }
  },
  emits: ["dismissed", "dismiss-count-down", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "dismissible"));
    i(s(a, "fade"));
    const n = i(s(a, "show")), r = G(), d = G(), v = u(() => ({
      [`alert-${a.variant}`]: !!a.variant,
      show: !!a.modelValue,
      "alert-dismissible": l.value,
      fade: !!a.modelValue
    }));
    let g;
    const B = (f) => {
      if (typeof f == "boolean")
        return 0;
      const m = xe(f, 0);
      return m > 0 ? m : 0;
    }, y = () => {
      g !== void 0 && (clearTimeout(g), g = void 0);
    }, h = G(B(a.modelValue)), T = u(() => !!a.modelValue || n.value);
    bt(() => {
      var f;
      y(), (f = d.value) == null || f.dispose(), d.value = void 0;
    });
    const V = u(() => a.modelValue === !0 ? !0 : a.modelValue === !1 || xe(a.modelValue, 0) < 1 ? !1 : !!a.modelValue), k = () => {
      h.value = B(a.modelValue), (V.value || n.value) && !d.value && (d.value = new nl(r.value));
    }, p = () => {
      typeof a.modelValue == "boolean" ? t("update:modelValue", !1) : t("update:modelValue", 0), t("dismissed");
    };
    return ie(() => a.modelValue, k), ie(() => n.value, k), ie(h, (f) => {
      y(), typeof a.modelValue != "boolean" && (t("dismiss-count-down", f), f === 0 && a.modelValue > 0 && t("dismissed"), a.modelValue !== f && t("update:modelValue", f), f > 0 && (g = setTimeout(() => {
        h.value--;
      }, 1e3)));
    }), (f, m) => o(T) ? (c(), b("div", {
      key: 0,
      ref_key: "element",
      ref: r,
      class: x(["alert", o(v)]),
      role: "alert"
    }, [
      $(f.$slots, "default"),
      o(l) ? (c(), b("button", {
        key: 0,
        type: "button",
        class: "btn-close",
        "data-bs-dismiss": "alert",
        "aria-label": e.dismissLabel,
        onClick: p
      }, null, 8, en)) : P("", !0)
    ], 2)) : P("", !0);
  }
}), da = Symbol(), an = /* @__PURE__ */ C({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: !1 },
    size: null,
    square: { default: !1 },
    tag: { default: "div" },
    variant: null
  },
  setup(e) {
    const t = e, a = i(s(t, "square")), l = u(() => rt(t.size)), n = (v) => Ae(v) && Wt(v) ? gt(v, 0) : v || 0, r = u(
      () => Math.min(Math.max(n(t.overlap), 0), 1) / 2
    ), d = u(() => {
      let { value: v } = l;
      return v = v ? `calc(${v} * ${r.value})` : null, v ? { paddingLeft: v, paddingRight: v } : {};
    });
    return Fe(da, {
      overlapScale: r,
      size: t.size,
      square: a.value,
      rounded: t.rounded,
      variant: t.variant
    }), (v, g) => (c(), N(q(e.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: L(() => [
        E("div", {
          class: "b-avatar-group-inner",
          style: _e(o(d))
        }, [
          $(v.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), ln = {
  key: 0,
  class: "b-avatar-custom"
}, nn = {
  key: 1,
  class: "b-avatar-img"
}, sn = ["src", "alt"], rt = (e) => {
  const t = Ae(e) && Wt(e) ? gt(e, 0) : e;
  return Ol(t) ? `${t}px` : t || null;
}, on = /* @__PURE__ */ C({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: null,
    badge: { type: [Boolean, String], default: !1 },
    badgeLeft: { default: !1 },
    badgeOffset: null,
    badgeTop: { default: !1 },
    badgeVariant: { default: "primary" },
    button: { default: !1 },
    buttonType: { default: "button" },
    disabled: { default: !1 },
    icon: null,
    rounded: { type: [Boolean, String], default: "circle" },
    size: null,
    square: { default: !1 },
    src: null,
    text: null,
    textVariant: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "badgeLeft")), n = i(s(a, "badgeTop")), r = i(s(a, "button")), d = i(s(a, "disabled")), v = i(s(a, "square")), g = Te(), B = ["sm", null, "lg"], y = 0.4, h = y * 0.7, T = Be(da, null), V = (J) => {
      const M = J;
      return M === "light" || M === "warning" ? "dark" : "light";
    }, k = u(() => !kt(g.default)), p = u(() => !kt(g.badge)), f = u(
      () => a.badge || a.badge === "" || p.value
    ), m = u(
      () => T != null && T.size ? T.size : rt(a.size)
    ), I = u(
      () => T != null && T.variant ? T.variant : a.variant
    ), z = u(
      () => T != null && T.rounded ? T.rounded : a.rounded
    ), S = u(() => ({
      "aria-label": a.ariaLabel || null,
      disabled: d.value || null
    })), _ = u(() => ({
      [`bg-${a.badgeVariant}`]: a.badgeVariant
    })), F = u(() => a.badge === !0 ? "" : a.badge), j = u(() => `text-${V(a.badgeVariant)}`), A = u(() => ({
      [`b-avatar-${a.size}`]: a.size && B.indexOf(rt(a.size)) !== -1,
      [`bg-${I.value}`]: I.value,
      badge: !r.value && I.value && k.value,
      rounded: z.value === "" || z.value === !0,
      ["rounded-circle"]: !v.value && z.value === "circle",
      ["rounded-0"]: v.value || z.value === "0",
      ["rounded-1"]: !v.value && z.value === "sm",
      ["rounded-3"]: !v.value && z.value === "lg",
      ["rounded-top"]: !v.value && z.value === "top",
      ["rounded-bottom"]: !v.value && z.value === "bottom",
      ["rounded-start"]: !v.value && z.value === "left",
      ["rounded-end"]: !v.value && z.value === "right",
      btn: r.value,
      [`btn-${I.value}`]: r.value ? I.value : null
    })), w = u(() => `text-${a.textVariant || V(I.value)}`), O = u(() => {
      const J = a.badgeOffset || "0px";
      return {
        fontSize: (B.indexOf(m.value || null) === -1 ? `calc(${m.value} * ${h})` : "") || "",
        top: n.value ? J : "",
        bottom: n.value ? "" : J,
        left: l.value ? J : "",
        right: l.value ? "" : J
      };
    }), K = u(() => {
      const J = B.indexOf(m.value || null) === -1 ? `calc(${m.value} * ${y})` : null;
      return J ? { fontSize: J } : {};
    }), Z = u(() => {
      var ue;
      const J = ((ue = T == null ? void 0 : T.overlapScale) == null ? void 0 : ue.value) || 0, M = m.value && J ? `calc(${m.value} * -${J})` : null;
      return M ? { marginLeft: M, marginRight: M } : {};
    }), Y = u(() => r.value ? a.buttonType : "span"), R = u(() => ({
      ...Z.value,
      width: m.value,
      height: m.value
    })), se = (J) => {
      !d.value && r.value && t("click", J);
    }, re = (J) => t("img-error", J);
    return (J, M) => (c(), N(q(o(Y)), D({
      class: ["b-avatar", o(A)],
      style: o(R)
    }, o(S), { onClick: se }), {
      default: L(() => [
        o(k) ? (c(), b("span", ln, [
          $(J.$slots, "default")
        ])) : e.src ? (c(), b("span", nn, [
          E("img", {
            src: e.src,
            alt: e.alt,
            onError: re
          }, null, 40, sn)
        ])) : e.text ? (c(), b("span", {
          key: 2,
          class: x(["b-avatar-text", o(w)]),
          style: _e(o(K))
        }, H(e.text), 7)) : P("", !0),
        o(f) ? (c(), b("span", {
          key: 3,
          class: x(["b-avatar-badge", o(_)]),
          style: _e(o(O))
        }, [
          o(p) ? $(J.$slots, "badge", { key: 0 }) : (c(), b("span", {
            key: 1,
            class: x(o(j))
          }, H(o(F)), 3))
        ], 6)) : P("", !0)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
}), Ce = {
  active: { type: [Boolean, String], default: !1 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: !1 },
  disabled: { type: [Boolean, String], default: !1 },
  event: { type: [String, Array], default: "click" },
  exact: { type: [Boolean, String], default: !1 },
  exactActiveClass: { type: String, default: "router-link-exact-active" },
  href: { type: String },
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: !1 },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null }
}, rn = C({
  props: Ce,
  emits: ["click"],
  setup(e, { emit: t, attrs: a }) {
    const l = i(s(e, "active")), n = i(s(e, "append")), r = i(s(e, "disabled")), d = i(s(e, "exact")), v = i(s(e, "replace")), g = Xa(), B = G(null), y = u(() => {
      const k = e.routerComponentName.split("-").map((f) => f.charAt(0).toUpperCase() + f.slice(1)).join("");
      return !((g == null ? void 0 : g.appContext.app.component(k)) !== void 0) || r.value || !e.to ? "a" : e.routerComponentName;
    }), h = u(() => {
      const k = "#";
      if (e.href)
        return e.href;
      if (typeof e.to == "string")
        return e.to || k;
      const p = e.to;
      if (Object.prototype.toString.call(p) === "[object Object]" && (p.path || p.query || p.hash)) {
        const f = p.path || "", m = p.query ? `?${Object.keys(p.query).map((z) => `${z}=${p.query[z]}`).join("=")}` : "", I = !p.hash || p.hash.charAt(0) === "#" ? p.hash || "" : `#${p.hash}`;
        return `${f}${m}${I}` || k;
      }
      return k;
    }), T = u(() => ({
      to: e.to,
      href: h.value,
      target: e.target,
      rel: e.target === "_blank" && e.rel === null ? "noopener" : e.rel || null,
      tabindex: r.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": r.value ? "true" : null
    }));
    return {
      tag: y,
      routerAttr: T,
      link: B,
      clicked: (k) => {
        if (r.value) {
          k.preventDefault(), k.stopImmediatePropagation();
          return;
        }
        t("click", k);
      },
      activeBoolean: l,
      appendBoolean: n,
      disabledBoolean: r,
      replaceBoolean: v,
      exactBoolean: d
    };
  }
}), fe = (e, t) => {
  const a = e.__vccOpts || e;
  for (const [l, n] of t)
    a[l] = n;
  return a;
};
function un(e, t, a, l, n, r) {
  return e.tag === "router-link" ? (c(), N(q(e.tag), D({ key: 0 }, e.routerAttr, { custom: "" }), {
    default: L(({ href: d, navigate: v, isActive: g, isExactActive: B }) => [
      (c(), N(q(e.routerTag), D({
        ref: "link",
        href: d,
        class: [g && e.activeClass, B && e.exactActiveClass]
      }, e.$attrs, { onClick: v }), {
        default: L(() => [
          $(e.$slots, "default")
        ]),
        _: 2
      }, 1040, ["href", "class", "onClick"]))
    ]),
    _: 3
  }, 16)) : (c(), N(q(e.tag), D({
    key: 1,
    ref: "link",
    class: { active: e.activeBoolean, disabled: e.disabledBoolean }
  }, e.routerAttr, { onClick: e.clicked }), {
    default: L(() => [
      $(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "onClick"]));
}
const be = /* @__PURE__ */ fe(rn, [["render", un]]), Ct = Ye(Ce, ["event", "routerTag"]), dn = C({
  components: { BLink: be },
  props: {
    pill: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "span" },
    variant: { type: String, default: "secondary" },
    textIndicator: { type: [Boolean, String], default: !1 },
    dotIndicator: { type: [Boolean, String], default: !1 },
    ...Ct
  },
  setup(e) {
    const t = u(() => ze(e)), a = u(() => t.value ? be : e.tag), l = i(s(e, "pill")), n = i(s(e, "textIndicator")), r = i(s(e, "dotIndicator"));
    return {
      classes: u(() => ({
        [`bg-${e.variant}`]: e.variant,
        active: e.active,
        disabled: e.disabled,
        "text-dark": ["warning", "info", "light"].includes(e.variant),
        "rounded-pill": l.value,
        "position-absolute top-0 start-100 translate-middle": n.value || r.value,
        "p-2 border border-light rounded-circle": r.value,
        "text-decoration-none": t.value
      })),
      props: t.value ? Zt(Ct, e) : {},
      computedTag: a
    };
  }
});
function cn(e, t, a, l, n, r) {
  return c(), N(q(e.computedTag), D({
    class: ["badge", e.classes]
  }, e.props), {
    default: L(() => [
      $(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
const fn = /* @__PURE__ */ fe(dn, [["render", cn]]), vn = C({
  components: { BLink: be },
  props: {
    ...Ye(Ce, ["event", "routerTag"]),
    active: { type: [Boolean, String], default: !1 },
    ariaCurrent: { type: String, default: "location" },
    disabled: { type: [Boolean, String], default: !1 },
    text: { type: String, required: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = i(s(e, "active")), l = i(s(e, "disabled")), n = u(() => ({
      active: e.active
    })), r = u(
      () => a.value ? "span" : be
    ), d = u(() => ({
      "aria-current": a.value ? e.ariaCurrent : void 0
    }));
    return {
      liClasses: n,
      computedTag: r,
      computedAriaCurrent: d,
      clicked: (g) => {
        if (l.value || a.value) {
          g.preventDefault(), g.stopImmediatePropagation();
          return;
        }
        l.value || t("click", g);
      }
    };
  }
});
function bn(e, t, a, l, n, r) {
  return c(), b("li", {
    class: x(["breadcrumb-item", e.liClasses])
  }, [
    (c(), N(q(e.computedTag), D({ "aria-current": e.computedAriaCurrent }, e.$props, { onClick: e.clicked }), {
      default: L(() => [
        $(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-current", "onClick"]))
  ], 2);
}
const ca = /* @__PURE__ */ fe(vn, [["render", bn]]), mn = { "aria-label": "breadcrumb" }, gn = { class: "breadcrumb" }, pn = /* @__PURE__ */ C({
  __name: "BBreadcrumb",
  props: {
    items: null
  },
  setup(e) {
    const t = e, a = cl(), l = u(() => {
      const n = t.items || (a == null ? void 0 : a.items) || [];
      let r = !1;
      return n.map((v, g) => (typeof v == "string" && (v = { text: v }, g < n.length - 1 && (v.href = "#")), v.active && (r = !0), !v.active && !r && (v.active = g + 1 === n.length), v));
    });
    return (n, r) => (c(), b("nav", mn, [
      E("ol", gn, [
        $(n.$slots, "prepend"),
        (c(!0), b(X, null, te(o(l), (d, v) => (c(), N(ca, D({ key: v }, d), {
          default: L(() => [
            Q(H(d.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        $(n.$slots, "default"),
        $(n.$slots, "append")
      ])
    ]));
  }
}), hn = C({
  components: { BLink: be },
  props: {
    ...Ce,
    active: { type: [Boolean, String], default: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    href: { type: String, required: !1 },
    pill: { type: [Boolean, String], default: !1 },
    pressed: { type: [Boolean, String], default: null },
    rel: { type: String, default: null },
    size: { type: String },
    squared: { type: [Boolean, String], default: !1 },
    tag: { type: String, default: "button" },
    target: { type: String, default: "_self" },
    type: { type: String, default: "button" },
    variant: { type: String, default: "secondary" }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const a = i(s(e, "active")), l = i(s(e, "disabled")), n = i(s(e, "pill")), r = i(s(e, "pressed")), d = i(s(e, "squared")), v = u(() => r.value !== null), g = u(() => e.tag === "button" && !e.href && !e.to), B = u(() => ze(e)), y = u(() => !!e.to), h = u(() => e.href ? !1 : !g.value), T = u(() => ({
      [`btn-${e.variant}`]: e.variant,
      [`btn-${e.size}`]: e.size,
      active: a.value || r.value,
      "rounded-pill": n.value,
      "rounded-0": d.value,
      disabled: l.value
    })), V = u(() => ({
      "aria-disabled": h.value ? String(l.value) : null,
      "aria-pressed": v.value ? String(r.value) : null,
      autocomplete: v.value ? "off" : null,
      disabled: g.value ? l.value : null,
      href: e.href,
      rel: B.value ? e.rel : null,
      role: h.value || B.value ? "button" : null,
      target: B.value ? e.target : null,
      type: g.value ? e.type : null,
      to: g.value ? null : e.to,
      append: B.value ? e.append : null,
      activeClass: y.value ? e.activeClass : null,
      event: y.value ? e.event : null,
      exact: y.value ? e.exact : null,
      exactActiveClass: y.value ? e.exactActiveClass : null,
      replace: y.value ? e.replace : null,
      routerComponentName: y.value ? e.routerComponentName : null,
      routerTag: y.value ? e.routerTag : null
    })), k = u(
      () => y.value ? be : e.href ? "a" : e.tag
    );
    return {
      classes: T,
      attrs: V,
      computedTag: k,
      clicked: (f) => {
        if (l.value) {
          f.preventDefault(), f.stopPropagation();
          return;
        }
        t("click", f), v.value && t("update:pressed", !r.value);
      }
    };
  }
});
function yn(e, t, a, l, n, r) {
  return c(), N(q(e.computedTag), D({
    class: ["btn", e.classes]
  }, e.attrs, { onClick: e.clicked }), {
    default: L(() => [
      $(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "onClick"]);
}
const Le = /* @__PURE__ */ fe(hn, [["render", yn]]), Bn = /* @__PURE__ */ C({
  __name: "BButtonGroup",
  props: {
    ariaRole: { default: "group" },
    size: null,
    tag: { default: "div" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(s(t, "vertical")), l = u(() => ({
      "btn-group": !a.value,
      "btn-group-vertical": a.value,
      [`btn-group-${t.size}`]: t.size
    }));
    return (n, r) => (c(), N(q(e.tag), {
      class: x(o(l)),
      role: "group",
      "aria-role": e.ariaRole
    }, {
      default: L(() => [
        $(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-role"]));
  }
}), $n = ["aria-label"], kn = /* @__PURE__ */ C({
  __name: "BButtonToolbar",
  props: {
    ariaRole: { default: "group" },
    justify: { default: !1 }
  },
  setup(e) {
    const a = i(s(e, "justify")), l = u(() => ({
      "justify-content-between": a.value
    }));
    return (n, r) => (c(), b("div", {
      class: x([o(l), "btn-toolbar"]),
      role: "toolbar",
      "aria-label": e.ariaRole
    }, [
      $(n.$slots, "default")
    ], 10, $n));
  }
}), Sn = ["disabled"], fa = /* @__PURE__ */ C({
  __name: "BCloseButton",
  props: {
    disabled: { default: !1 },
    white: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(s(t, "disabled")), l = i(s(t, "white")), n = u(() => ({
      "btn-close-white": l.value
    }));
    return (r, d) => (c(), b("button", {
      type: "button",
      class: x(["btn-close", o(n)]),
      disabled: o(a),
      "aria-label": "Close"
    }, null, 10, Sn));
  }
}), Tn = ["innerHTML"], Cn = ["innerHTML"], Vn = /* @__PURE__ */ C({
  __name: "BCard",
  props: {
    align: null,
    bgVariant: null,
    bodyBgVariant: null,
    bodyClass: null,
    bodyTag: { default: "div" },
    bodyTextVariant: null,
    borderVariant: null,
    footer: null,
    footerBgVariant: null,
    footerBorderVariant: null,
    footerClass: null,
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: null,
    header: null,
    headerBgVariant: null,
    headerBorderVariant: null,
    headerClass: null,
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: null,
    imgAlt: null,
    imgBottom: { default: !1 },
    imgEnd: { default: !1 },
    imgHeight: null,
    imgLeft: { default: !1 },
    imgRight: { default: !1 },
    imgSrc: null,
    imgStart: { default: !1 },
    imgTop: { default: !1 },
    imgWidth: null,
    noBody: { default: !1 },
    overlay: { default: !1 },
    subTitle: null,
    subTitleTag: { default: "h6" },
    subTitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: null,
    title: null,
    titleTag: { default: "h4" }
  },
  setup(e) {
    const t = e, a = i(s(t, "imgBottom")), l = i(s(t, "imgEnd")), n = i(s(t, "imgLeft")), r = i(s(t, "imgRight")), d = i(s(t, "imgStart")), v = i(s(t, "imgTop")), g = i(s(t, "noBody")), B = i(s(t, "overlay")), y = u(() => ({
      [`text-${t.align}`]: t.align,
      [`text-${t.textVariant}`]: t.textVariant,
      [`bg-${t.bgVariant}`]: t.bgVariant,
      [`border-${t.borderVariant}`]: t.borderVariant,
      "flex-row": n.value || d.value,
      "flex-row-reverse": l.value || r.value
    })), h = u(() => ({
      "card-body": !g.value,
      "card-img-overlay": B.value,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant
    })), T = u(() => ({
      [`bg-${t.footerBgVariant}`]: t.footerBgVariant,
      [`border-${t.footerBorderVariant}`]: t.footerBorderVariant,
      [`text-${t.footerTextVariant}`]: t.footerTextVariant
    })), V = u(() => ({
      [`bg-${t.headerBgVariant}`]: t.headerBgVariant,
      [`border-${t.headerBorderVariant}`]: t.headerBorderVariant,
      [`text-${t.headerTextVariant}`]: t.headerTextVariant
    })), k = u(() => ({
      "card-img": !l.value && !r.value && !d.value && !n.value && !v.value && !v.value,
      "card-img-right": l.value || r.value,
      "card-img-left": d.value || n.value,
      "card-img-top": v.value,
      "card-img-bottom": a.value
    })), p = u(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth
    })), f = u(() => ({
      [`text-${t.subTitleTextVariant}`]: t.subTitleTextVariant
    }));
    return (m, I) => (c(), N(q(e.tag), {
      class: x(["card", o(y)])
    }, {
      default: L(() => [
        e.imgSrc && !o(a) ? (c(), b("img", D({ key: 0 }, o(p), { class: o(k) }), null, 16)) : P("", !0),
        e.header || m.$slots.header || e.headerHtml ? (c(), N(q(e.headerTag), {
          key: 1,
          class: x(["card-header", [e.headerClass, o(V)]])
        }, {
          default: L(() => [
            e.headerHtml ? (c(), b("div", {
              key: 0,
              innerHTML: e.headerHtml
            }, null, 8, Tn)) : $(m.$slots, "header", { key: 1 }, () => [
              Q(H(e.header), 1)
            ])
          ]),
          _: 3
        }, 8, ["class"])) : P("", !0),
        o(g) ? P("", !0) : (c(), N(q(e.bodyTag), {
          key: 2,
          class: x([e.bodyClass, o(h)])
        }, {
          default: L(() => [
            e.title && !o(g) ? (c(), N(q(e.titleTag), {
              key: 0,
              class: "card-title"
            }, {
              default: L(() => [
                Q(H(e.title), 1)
              ]),
              _: 1
            })) : P("", !0),
            e.subTitle && !o(g) ? (c(), N(q(e.subTitleTag), {
              key: 1,
              class: x(["card-subtitle mb-2", o(f)])
            }, {
              default: L(() => [
                Q(H(e.subTitle), 1)
              ]),
              _: 1
            }, 8, ["class"])) : P("", !0),
            $(m.$slots, "default")
          ]),
          _: 3
        }, 8, ["class"])),
        o(g) ? $(m.$slots, "default", { key: 3 }) : P("", !0),
        e.footer || m.$slots.footer || e.footerHtml ? (c(), N(q(e.footerTag), {
          key: 4,
          class: x(["card-footer", [e.footerClass, o(T)]])
        }, {
          default: L(() => [
            e.footerHtml ? (c(), b("div", {
              key: 0,
              innerHTML: e.footerHtml
            }, null, 8, Cn)) : $(m.$slots, "footer", { key: 1 }, () => [
              Q(H(e.footer), 1)
            ])
          ]),
          _: 3
        }, 8, ["class"])) : P("", !0),
        e.imgSrc && o(a) ? (c(), b("img", D({ key: 5 }, o(p), { class: o(k) }), null, 16)) : P("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), va = /* @__PURE__ */ C({
  __name: "BCardTitle",
  props: {
    title: null,
    titleTag: { default: "h4" }
  },
  setup(e) {
    return (t, a) => (c(), N(q(e.titleTag), { class: "card-title" }, {
      default: L(() => [
        $(t.$slots, "default", {}, () => [
          Q(H(e.title), 1)
        ])
      ]),
      _: 3
    }));
  }
}), ba = /* @__PURE__ */ C({
  __name: "BCardSubTitle",
  props: {
    subTitle: null,
    subTitleTag: { default: "h6" },
    subTitleTextVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`text-${t.subTitleTextVariant}`]: t.subTitleTextVariant
    }));
    return (l, n) => (c(), N(q(e.subTitleTag), {
      class: x(["card-subtitle mb-2", o(a)])
    }, {
      default: L(() => [
        $(l.$slots, "default", {}, () => [
          Q(H(e.subTitle), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), wn = /* @__PURE__ */ C({
  __name: "BCardBody",
  props: {
    bodyBgVariant: null,
    bodyClass: null,
    bodyTag: { default: "div" },
    bodyTextVariant: null,
    overlay: { default: !1 },
    subTitle: null,
    subTitleTag: { default: "h4" },
    subTitleTextVariant: null,
    title: null,
    titleTag: { default: "h4" }
  },
  setup(e) {
    const t = e;
    i(s(t, "overlay"));
    const a = u(() => ({
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant
    }));
    return (l, n) => (c(), N(q(e.bodyTag), {
      class: x(["card-body", o(a)])
    }, {
      default: L(() => [
        e.title ? (c(), N(va, {
          key: 0,
          "title-tag": e.titleTag,
          title: e.title
        }, null, 8, ["title-tag", "title"])) : P("", !0),
        e.subTitle ? (c(), N(ba, {
          key: 1,
          "sub-title-tag": e.subTitleTag,
          "sub-title": e.subTitle,
          "sub-title-text-variant": e.subTitleTextVariant
        }, null, 8, ["sub-title-tag", "sub-title", "sub-title-text-variant"])) : P("", !0),
        $(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), _n = ["innerHTML"], An = /* @__PURE__ */ C({
  __name: "BCardFooter",
  props: {
    footer: null,
    footerBgVariant: null,
    footerBorderVariant: null,
    footerClass: null,
    footerHtml: null,
    footerTag: { default: "div" },
    footerTextVariant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`text-${t.footerTextVariant}`]: t.footerTextVariant,
      [`bg-${t.footerBgVariant}`]: t.footerBgVariant,
      [`border-${t.footerBorderVariant}`]: t.footerBorderVariant
    }));
    return (l, n) => (c(), N(q(e.footerTag), {
      class: x(["card-footer", [e.footerClass, o(a)]])
    }, {
      default: L(() => [
        e.footerHtml ? (c(), b("div", {
          key: 0,
          innerHTML: e.footerHtml
        }, null, 8, _n)) : $(l.$slots, "default", { key: 1 }, () => [
          Q(H(e.footer), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), xn = /* @__PURE__ */ C({
  __name: "BCardGroup",
  props: {
    columns: { default: !1 },
    deck: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = i(s(t, "columns")), l = i(s(t, "deck")), n = u(
      () => l.value ? "card-deck" : a.value ? "card-columns" : "card-group"
    );
    return (r, d) => (c(), N(q(e.tag), {
      class: x(o(n))
    }, {
      default: L(() => [
        $(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Fn = ["innerHTML"], In = /* @__PURE__ */ C({
  __name: "BCardHeader",
  props: {
    header: null,
    headerBgVariant: null,
    headerBorderVariant: null,
    headerClass: null,
    headerHtml: null,
    headerTag: { default: "div" },
    headerTextVariant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`text-${t.headerTextVariant}`]: t.headerTextVariant,
      [`bg-${t.headerBgVariant}`]: t.headerBgVariant,
      [`border-${t.headerBorderVariant}`]: t.headerBorderVariant
    }));
    return (l, n) => (c(), N(q(e.headerTag), {
      class: x(["card-header", [e.headerClass, o(a)]])
    }, {
      default: L(() => [
        e.headerHtml ? (c(), b("div", {
          key: 0,
          innerHTML: e.headerHtml
        }, null, 8, Fn)) : $(l.$slots, "default", { key: 1 }, () => [
          Q(H(e.header), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), On = /* @__PURE__ */ C({
  __name: "BCardImg",
  props: {
    alt: { default: void 0 },
    bottom: { default: !1 },
    end: { default: !1 },
    height: null,
    left: { default: !1 },
    right: { default: !1 },
    src: null,
    start: { default: !1 },
    top: { default: !1 },
    width: null
  },
  setup(e) {
    const t = e, a = i(s(t, "bottom")), l = i(s(t, "end")), n = i(s(t, "left")), r = i(s(t, "right")), d = i(s(t, "start")), v = i(s(t, "top")), g = u(() => ({
      src: t.src,
      alt: t.alt,
      width: (typeof t.width == "number" ? t.width : parseInt(t.width, 10)) || void 0,
      height: (typeof t.height == "number" ? t.height : parseInt(t.height, 10)) || void 0
    })), B = u(() => {
      const y = n.value ? "float-left" : r.value ? "float-right" : "";
      let h = "card-img";
      return v.value ? h += "-top" : r.value || l.value ? h += "-right" : a.value ? h += "-bottom" : (n.value || d.value) && (h += "-left"), {
        [y]: !!y,
        [h]: !0
      };
    });
    return (y, h) => (c(), b("img", D({ class: o(B) }, o(g)), null, 16));
  }
}), Nn = {}, zn = { class: "card-text" };
function Ln(e, t) {
  return c(), b("p", zn, [
    $(e.$slots, "default")
  ]);
}
const Pn = /* @__PURE__ */ fe(Nn, [["render", Ln]]), En = ["id"], Hn = {
  key: 0,
  class: "carousel-indicators"
}, qn = ["data-bs-target", "data-bs-slide-to", "aria-label"], Rn = { class: "carousel-inner" }, jn = ["data-bs-target"], Dn = /* @__PURE__ */ E("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), Mn = /* @__PURE__ */ E("span", { class: "visually-hidden" }, "Previous", -1), Gn = [
  Dn,
  Mn
], Un = ["data-bs-target"], Wn = /* @__PURE__ */ E("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Xn = /* @__PURE__ */ E("span", { class: "visually-hidden" }, "Next", -1), Kn = [
  Wn,
  Xn
], ma = Symbol(), Jn = /* @__PURE__ */ C({
  __name: "BCarousel",
  props: {
    id: null,
    imgHeight: null,
    imgWidth: null,
    background: null,
    modelValue: { default: 0 },
    controls: { default: !1 },
    indicators: { default: !1 },
    interval: { default: 5e3 },
    noTouch: { default: !1 },
    noWrap: { default: !1 }
  },
  emits: ["sliding-start", "sliding-end"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "controls")), n = i(s(a, "indicators")), r = i(s(a, "noTouch"));
    i(s(a, "noWrap"));
    const d = Te(), v = G(), g = G(), B = ce(s(a, "id"), "accordion"), y = G([]);
    return ae(v, "slide.bs.carousel", (h) => t("sliding-start", h)), ae(v, "slid.bs.carousel", (h) => t("sliding-end", h)), de(() => {
      g.value = new sl(v.value, {
        wrap: !r.value,
        interval: a.interval,
        touch: !r.value
      }), d.default && (y.value = d.default().filter((h) => {
        var T;
        return ((T = h.type) == null ? void 0 : T.name) === "BCarouselSlide";
      }));
    }), Fe(ma, {
      background: a.background,
      width: a.imgWidth,
      height: a.imgHeight
    }), (h, T) => (c(), b("div", {
      id: o(B),
      ref_key: "element",
      ref: v,
      class: "carousel slide",
      "data-bs-ride": "carousel"
    }, [
      o(n) ? (c(), b("div", Hn, [
        (c(!0), b(X, null, te(y.value, (V, k) => (c(), b("button", {
          key: k,
          type: "button",
          "data-bs-target": `#${o(B)}`,
          "data-bs-slide-to": k,
          class: x(k === 0 ? "active" : ""),
          "aria-current": "true",
          "aria-label": `Slide ${k}`
        }, null, 10, qn))), 128))
      ])) : P("", !0),
      E("div", Rn, [
        $(h.$slots, "default")
      ]),
      o(l) ? (c(), b(X, { key: 1 }, [
        E("button", {
          class: "carousel-control-prev",
          type: "button",
          "data-bs-target": `#${o(B)}`,
          "data-bs-slide": "prev"
        }, Gn, 8, jn),
        E("button", {
          class: "carousel-control-next",
          type: "button",
          "data-bs-target": `#${o(B)}`,
          "data-bs-slide": "next"
        }, Kn, 8, Un)
      ], 64)) : P("", !0)
    ], 8, En));
  }
}), Yn = ["id", "data-bs-interval"], Zn = { key: 0 }, Qn = ["innerHTML"], es = { key: 0 }, ts = ["innerHTML"], as = /* @__PURE__ */ C({
  __name: "BCarouselSlide",
  props: {
    imgSrc: null,
    imgHeight: null,
    imgWidth: null,
    interval: null,
    active: { default: !1 },
    background: null,
    caption: null,
    captionHtml: null,
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: null,
    id: null,
    imgAlt: null,
    imgBlank: { default: !1 },
    imgBlankColor: { default: "transparent" },
    text: null,
    textHtml: null,
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, a = i(s(t, "active")), l = i(s(t, "imgBlank")), n = Be(ma, {}), r = ce(s(t, "id"), "accordion");
    u(
      () => l.value ? l.value : t.imgSrc
    );
    const d = u(() => ({
      background: `${t.background || n.background || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), v = u(() => ({
      "d-none": t.contentVisibleUp,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp
    })), g = u(() => t.text && !t.textHtml), B = u(() => t.textHtml), y = u(() => t.caption && !t.captionHtml), h = u(() => t.captionHtml), T = u(() => n.width), V = u(() => n.height);
    return (k, p) => {
      const f = We("b-img");
      return c(), b("div", {
        id: o(r),
        class: x(["carousel-item", { active: o(a) }]),
        "data-bs-interval": e.interval,
        style: _e(o(d))
      }, [
        $(k.$slots, "img", {}, () => [
          ge(f, {
            class: "d-block w-100",
            alt: e.imgAlt,
            src: e.imgSrc,
            width: e.imgWidth || o(T),
            height: e.imgHeight || o(V),
            blank: o(l),
            "blank-color": e.imgBlankColor
          }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
        ]),
        e.caption || e.captionHtml || e.text || e.textHtml || k.$slots.default ? (c(), N(q(e.contentTag), {
          key: 0,
          class: x(["carousel-caption", o(v)])
        }, {
          default: L(() => [
            e.caption || e.captionHtml ? (c(), N(q(e.captionTag), { key: 0 }, {
              default: L(() => [
                o(y) ? (c(), b("span", Zn, H(e.caption), 1)) : P("", !0),
                o(h) ? (c(), b("span", {
                  key: 1,
                  innerHTML: e.captionHtml
                }, null, 8, Qn)) : P("", !0)
              ]),
              _: 1
            })) : P("", !0),
            e.text || e.textHtml ? (c(), N(q(e.textTag), { key: 1 }, {
              default: L(() => [
                o(g) ? (c(), b("span", es, H(e.text), 1)) : P("", !0),
                o(B) ? (c(), b("span", {
                  key: 1,
                  innerHTML: e.textHtml
                }, null, 8, ts)) : P("", !0)
              ]),
              _: 1
            })) : P("", !0),
            $(k.$slots, "default")
          ]),
          _: 3
        }, 8, ["class"])) : P("", !0)
      ], 14, Yn);
    };
  }
}), Vt = Ke("", [], { type: [Boolean, String, Number], default: !1 }), wt = Ke("offset", [""], { type: [String, Number], default: null }), _t = Ke("order", [""], { type: [String, Number], default: null }), ls = C({
  name: "BCol",
  props: {
    col: { type: [Boolean, String], default: !1 },
    cols: { type: [String, Number], default: null },
    ...Vt,
    offset: { type: [String, Number], default: null },
    ...wt,
    order: { type: [String, Number], default: null },
    ..._t,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = i(s(e, "col")), a = [
      { content: Vt, propPrefix: "cols", classPrefix: "col" },
      { content: wt, propPrefix: "offset" },
      { content: _t, propPrefix: "order" }
    ], l = u(
      () => a.flatMap((r) => Gt(e, r.content, r.propPrefix, r.classPrefix))
    );
    return {
      classes: u(() => ({
        col: t.value || !l.value.some((r) => /^col-/.test(r) && !e.cols),
        [`col-${e.cols}`]: !!e.cols,
        [`offset-${e.offset}`]: !!e.offset,
        [`order-${e.order}`]: !!e.order,
        [`align-self-${e.alignSelf}`]: !!e.alignSelf
      })),
      classList: l
    };
  }
});
function ns(e, t, a, l, n, r) {
  return c(), N(q(e.tag), {
    class: x([e.classes, e.classList])
  }, {
    default: L(() => [
      $(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Ie = /* @__PURE__ */ fe(ls, [["render", ns]]), Ve = { delay: 5e3, value: !0, pos: "top-right" };
class At {
  constructor(t) {
    le(this, "vm");
    le(this, "containerPositions");
    Ka(t) ? this.vm = t : this.vm = ye(t), this.containerPositions = u(() => {
      const a = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((l) => {
        l.options.pos && a.add(l.options.pos);
      }), a;
    });
  }
  toasts(t) {
    return t ? u(
      () => this.vm.toasts.filter((a) => {
        if (a.options.pos === t && a.options.value)
          return a;
      })
    ) : u(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((a) => {
      if (a.options.id && !t.includes(a.options.id))
        return a;
    });
  }
  isRoot() {
    var t;
    return (t = this.vm.root) != null ? t : !1;
  }
  show(t, a = Ve) {
    const l = { id: he(), ...Ve, ...a }, n = {
      options: ye(l),
      content: t
    };
    return this.vm.toasts.push(n), n;
  }
  info(t, a = Ve) {
    return this.show(t, { variant: "info", ...a });
  }
  danger(t, a = Ve) {
    return this.show(t, { variant: "danger", ...a });
  }
  warning(t, a = Ve) {
    return this.show(t, { variant: "warning", ...a });
  }
  success(t, a = Ve) {
    return this.show(t, { variant: "success", ...a });
  }
  hide() {
  }
}
class ss {
  constructor() {
    le(this, "vms");
    le(this, "rootInstance");
    le(this, "useToast", pa);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const a = { root: !0, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = a.id, this.vms[a.id] = a, a;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
}
const ut = Symbol(), ga = Symbol(), os = {
  container: void 0,
  toasts: [],
  root: !1
};
function is() {
  return Be(ga);
}
function pa(e, t = ut) {
  const a = Be(is());
  if (!e)
    return new At(a.getOrCreateViewModel());
  const l = { id: Symbol("toastInstance") }, n = { ...os, ...l, ...e }, r = a.getOrCreateViewModel(n);
  return new At(r);
}
const rs = {
  install: (e, t = {}) => {
    var a, l, n, r;
    e.provide(ga, (l = (a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) != null ? l : ut), e.provide((r = (n = t == null ? void 0 : t.BToast) == null ? void 0 : n.injectkey) != null ? r : ut, new ss());
  }
}, dt = /* @__PURE__ */ C({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: null
  },
  setup(e) {
    const t = e, a = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, l = u(() => a[t.position]), n = (r) => {
      var d;
      (d = t.instance) == null || d.remove(r);
    };
    return (r, d) => {
      var g;
      const v = We("b-toast");
      return c(), b("div", {
        class: x([[o(l)], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (c(!0), b(X, null, te((g = e.instance) == null ? void 0 : g.toasts(e.position).value, (B) => (c(), N(v, {
          id: B.options.id,
          key: B.options.id,
          modelValue: B.options.value,
          "onUpdate:modelValue": (y) => B.options.value = y,
          delay: B.options.delay,
          title: B.content.title,
          body: B.content.body,
          component: B.content.body,
          variant: B.options.variant,
          onDestroyed: n
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "delay", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
}), us = C({
  name: "BContainer",
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: !1 },
    toast: { type: Object },
    position: { type: String, required: !1 }
  },
  setup(e, { slots: t, expose: a }) {
    const l = G();
    let n;
    const r = u(() => ({
      container: !e.fluid,
      ["container-fluid"]: typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return de(() => {
      e.toast;
    }), e.toast && (n = pa({ container: l, root: e.toast.root }), a({})), () => {
      var v;
      const d = [];
      return n == null || n.containerPositions.value.forEach((g) => {
        d.push(W(dt, { key: g, instance: n, position: g }));
      }), W("div", { class: [r.value, e.position], ref: l }, [
        ...d,
        (v = t.default) == null ? void 0 : v.call(t)
      ]);
    };
  },
  methods: {}
}), ds = { class: "visually-hidden" }, cs = ["aria-labelledby", "role"], ha = /* @__PURE__ */ C({
  __name: "BDropdown",
  props: {
    id: null,
    menuClass: null,
    size: null,
    splitClass: null,
    splitVariant: null,
    text: null,
    toggleClass: null,
    autoClose: { type: [Boolean, String], default: !0 },
    block: { default: !1 },
    boundary: { default: "clippingParents" },
    dark: { default: !1 },
    disabled: { default: !1 },
    dropup: { default: !1 },
    dropright: { default: !1 },
    dropleft: { default: !1 },
    noFlip: { default: !1 },
    offset: { default: 0 },
    popperOpts: { default: () => ({}) },
    right: { default: !1 },
    role: { default: "menu" },
    split: { default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    noCaret: { default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" }
  },
  emits: ["show", "shown", "hide", "hidden", "click", "toggle"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = i(s(l, "block")), r = i(s(l, "dark")), d = i(s(l, "disabled")), v = i(s(l, "dropup")), g = i(s(l, "dropright")), B = i(s(l, "dropleft")), y = i(s(l, "right")), h = i(s(l, "split")), T = i(s(l, "noCaret")), V = G(), k = G(), p = G(), f = ce(s(l, "id"), "dropdown");
    ae(V, "show.bs.dropdown", () => a("show")), ae(V, "shown.bs.dropdown", () => a("shown")), ae(V, "hide.bs.dropdown", () => a("hide")), ae(V, "hidden.bs.dropdown", () => a("hidden"));
    const m = (A) => {
      h.value && a("click", A);
    }, I = u(() => ({
      "d-grid": n.value,
      "d-flex": n.value && h.value
    })), z = u(() => ({
      "dropdown-toggle": !h.value,
      "dropdown-toggle-no-caret": T.value && !h.value,
      "w-100": h.value && n.value
    })), S = u(() => ({
      "dropdown-menu-dark": r.value,
      "dropdown-menu-right": y.value
    })), _ = u(() => ({
      "data-bs-toggle": h.value ? void 0 : "dropdown",
      "aria-expanded": h.value ? void 0 : !1,
      ref: h.value ? void 0 : k,
      href: h.value ? l.splitHref : void 0
    })), F = u(() => ({
      ref: h.value ? k : void 0
    })), j = () => {
      var A;
      (A = p.value) == null || A.hide();
    };
    return de(() => {
      var A;
      p.value = new ol((A = k.value) == null ? void 0 : A.$el, {
        autoClose: l.autoClose,
        boundary: l.boundary,
        offset: l.offset ? l.offset.toString() : "",
        reference: l.offset || h.value ? "parent" : "toggle",
        popperConfig: (w) => {
          const O = {
            placement: "bottom-start",
            modifiers: l.noFlip ? [
              {
                name: "flip",
                options: {
                  fallbackPlacements: []
                }
              }
            ] : []
          };
          return v.value ? O.placement = y.value ? "top-end" : "top-start" : g.value ? O.placement = "right-start" : B.value ? O.placement = "left-start" : y.value && (O.placement = "bottom-end"), ot(w, ot(O, l.popperOpts));
        }
      });
    }), t({
      hide: j
    }), (A, w) => (c(), b("div", {
      ref_key: "parent",
      ref: V,
      class: x([o(I), "btn-group"])
    }, [
      ge(Le, D({
        id: o(f),
        variant: e.splitVariant || e.variant,
        size: e.size,
        class: [o(z), o(h) ? e.splitClass : e.toggleClass],
        disabled: o(d),
        type: e.splitButtonType
      }, o(_), { onClick: m }), {
        default: L(() => [
          Q(H(e.text) + " ", 1),
          $(A.$slots, "button-content")
        ]),
        _: 3
      }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
      o(h) ? (c(), N(Le, D({
        key: 0,
        variant: e.variant,
        size: e.size,
        disabled: o(d)
      }, o(F), {
        class: [e.toggleClass, "dropdown-toggle-split dropdown-toggle"],
        "data-bs-toggle": "dropdown",
        "aria-expanded": "false",
        onClick: w[0] || (w[0] = (O) => a("toggle"))
      }), {
        default: L(() => [
          E("span", ds, H(e.toggleText), 1)
        ]),
        _: 1
      }, 16, ["variant", "size", "disabled", "class"])) : P("", !0),
      E("ul", {
        class: x(["dropdown-menu", [e.menuClass, o(S)]]),
        "aria-labelledby": o(f),
        role: e.role
      }, [
        $(A.$slots, "default")
      ], 10, cs)
    ], 2));
  }
}), fs = { role: "presentation" }, vs = /* @__PURE__ */ C({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, a) => (c(), b("li", fs, [
      (c(), N(q(e.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), bs = {}, ms = { role: "presentation" }, gs = { class: "px-4 py-3" };
function ps(e, t) {
  return c(), b("li", ms, [
    E("form", gs, [
      $(e.$slots, "default")
    ])
  ]);
}
const hs = /* @__PURE__ */ fe(bs, [["render", ps]]), ys = { role: "presentation" }, Bs = ["id", "aria-describedby"], $s = {
  inheritAttrs: !1
}, ks = /* @__PURE__ */ C({
  ...$s,
  __name: "BDropdownGroup",
  props: {
    id: null,
    ariaDescribedby: null,
    header: null,
    headerClasses: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, a = u(
      () => t.id ? [t.id, "group_dd_header"].join("_") : void 0
    ), l = u(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), n = u(() => ({
      [`text-${t.headerVariant}`]: t.headerVariant
    }));
    return (r, d) => (c(), b("li", ys, [
      (c(), N(q(e.headerTag), {
        id: o(a),
        class: x(["dropdown-header", [o(n), e.headerClasses]]),
        role: o(l)
      }, {
        default: L(() => [
          $(r.$slots, "header", {}, () => [
            Q(H(e.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      E("ul", D({
        id: e.id,
        role: "group",
        class: "list-unstyled"
      }, r.$attrs, {
        "aria-describedby": e.ariaDescribedby || o(a)
      }), [
        $(r.$slots, "default")
      ], 16, Bs)
    ]));
  }
}), Ss = {}, Ts = { class: "dropdown-header" };
function Cs(e, t) {
  return c(), b("li", null, [
    E("h6", Ts, [
      $(e.$slots, "default")
    ])
  ]);
}
const Vs = /* @__PURE__ */ fe(Ss, [["render", Cs]]), ws = { role: "presentation" }, _s = {
  inheritAttrs: !1
}, As = /* @__PURE__ */ C({
  ..._s,
  __name: "BDropdownItem",
  props: {
    href: null,
    linkClass: null,
    active: { default: !1 },
    disabled: { default: !1 },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "active")), n = i(s(a, "disabled")), r = Pt(), d = u(() => ({
      active: l.value,
      disabled: n.value,
      [`text-${a.variant}`]: a.variant
    })), v = u(
      () => a.href ? "a" : r.to ? be : "button"
    ), g = u(() => ({
      "aria-current": l.value ? "true" : null,
      href: v.value === "a" ? a.href : null,
      rel: a.rel,
      type: v.value === "button" ? "button" : null,
      target: a.target,
      ...r.to ? { activeClass: "active", ...r } : {}
    })), B = (y) => t("click", y);
    return (y, h) => (c(), b("li", ws, [
      (c(), N(q(o(v)), D({
        class: ["dropdown-item", [o(d), e.linkClass]]
      }, o(g), { onClick: B }), {
        default: L(() => [
          $(y.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ]));
  }
}), xs = { role: "presentation" }, Fs = {
  inheritAttrs: !1
}, Is = /* @__PURE__ */ C({
  ...Fs,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: null,
    active: { default: !1 },
    activeClass: { default: "active" },
    disabled: { default: !1 },
    variant: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "active")), n = i(s(a, "disabled")), r = u(() => ({
      [a.activeClass]: l.value,
      disabled: n.value,
      [`text-${a.variant}`]: a.variant
    })), d = u(() => ({
      role: "menuitem",
      type: "button",
      disabled: n.value
    })), v = (g) => t("click", g);
    return (g, B) => (c(), b("li", xs, [
      E("button", D({
        class: ["dropdown-item", [o(r), e.buttonClass]]
      }, o(d), { onClick: v }), [
        $(g.$slots, "default")
      ], 16)
    ]));
  }
}), Os = {}, Ns = { role: "presentation" }, zs = { class: "px-4 py-1 mb-0 text-muted" };
function Ls(e, t) {
  return c(), b("li", Ns, [
    E("p", zs, [
      $(e.$slots, "default")
    ])
  ]);
}
const Ps = /* @__PURE__ */ fe(Os, [["render", Ls]]), Es = ["id", "novalidate", "onSubmit"], ya = /* @__PURE__ */ C({
  __name: "BForm",
  props: {
    id: null,
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "floating")), n = i(s(a, "novalidate")), r = i(s(a, "validated")), d = u(() => ({
      "form-floating": l.value,
      "was-validated": r.value
    })), v = (g) => t("submit", g);
    return (g, B) => (c(), b("form", {
      id: e.id,
      novalidate: o(n),
      class: x(o(d)),
      onSubmit: Et(v, ["prevent"])
    }, [
      $(g.$slots, "default")
    ], 42, Es));
  }
}), Hs = { class: "form-floating" }, qs = ["for"], Rs = /* @__PURE__ */ C({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: null,
    label: null
  },
  setup(e) {
    return (t, a) => (c(), b("div", Hs, [
      $(t.$slots, "default"),
      E("label", { for: e.labelFor }, H(e.label), 9, qs)
    ]));
  }
}), ct = /* @__PURE__ */ C({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: null,
    forceShow: { default: !1 },
    id: null,
    role: null,
    state: { default: void 0 },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(s(t, "forceShow")), l = t.state !== void 0 ? i(s(t, "state")) : u(() => {
    }), n = i(s(t, "tooltip")), r = u(
      () => a.value === !0 || l.value === !1
    ), d = u(() => ({
      "d-block": r.value,
      "invalid-feedback": !n.value,
      "invalid-tooltip": n.value
    })), v = u(() => ({
      id: t.id || null,
      role: t.role || null,
      "aria-live": t.ariaLive || null,
      "aria-atomic": t.ariaLive ? "true" : null
    }));
    return (g, B) => (c(), N(q(e.tag), D({ class: o(d) }, o(v)), {
      default: L(() => [
        $(g.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), je = /* @__PURE__ */ C({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, a) => (c(), N(q(e.tag), { class: "row d-flex flex-wrap" }, {
      default: L(() => [
        $(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), ft = /* @__PURE__ */ C({
  __name: "BFormText",
  props: {
    id: null,
    inline: { default: !1 },
    tag: { default: "small" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, a = i(s(t, "inline")), l = u(() => ({
      "form-text": !a.value,
      [`text-${t.textVariant}`]: t.textVariant
    })), n = u(() => ({
      id: t.id || null
    }));
    return (r, d) => (c(), N(q(e.tag), D({ class: o(l) }, o(n)), {
      default: L(() => [
        $(r.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), vt = /* @__PURE__ */ C({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: null,
    forceShow: { default: !1 },
    id: null,
    role: null,
    state: { default: void 0 },
    tag: { default: "div" },
    tooltip: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(s(t, "forceShow")), l = t.state !== void 0 ? i(s(t, "state")) : u(() => {
    }), n = i(s(t, "tooltip")), r = u(
      () => a.value === !0 || l.value === !0
    ), d = u(() => ({
      "d-block": r.value,
      "valid-feedback": !n.value,
      "valid-tooltip": n.value
    })), v = u(() => ({
      id: t.id || null,
      role: t.role || null,
      "aria-live": t.ariaLive || null,
      "aria-atomic": t.ariaLive ? "true" : null
    }));
    return (g, B) => (c(), N(q(e.tag), D({ class: o(d) }, o(v)), {
      default: L(() => [
        $(g.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), js = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"], Ds = ["for"], Ms = {
  inheritAttrs: !1
}, Ba = /* @__PURE__ */ C({
  ...Ms,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: null,
    ariaLabelledBy: null,
    form: null,
    indeterminate: null,
    name: null,
    id: { default: void 0 },
    autofocus: { default: !1 },
    plain: { default: !1 },
    button: { default: !1 },
    switch: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: "secondary" },
    inline: { default: !1 },
    required: { default: void 0 },
    size: { default: "md" },
    state: { default: void 0 },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number], default: !1 },
    value: { type: [Array, Set, Boolean, String, Object, Number], default: !0 },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { emit: t }) {
    const a = e, l = a.indeterminate !== void 0 ? i(s(a, "indeterminate")) : u(() => {
    }), n = i(s(a, "autofocus")), r = i(s(a, "plain")), d = i(s(a, "button")), v = i(s(a, "switch")), g = i(s(a, "disabled")), B = i(s(a, "inline")), y = a.required !== void 0 ? i(s(a, "required")) : u(() => {
    }), h = a.state !== void 0 ? i(s(a, "state")) : u(() => {
    }), T = ce(s(a, "id"), "form-check"), V = G(null), k = G(!1), p = u({
      get: () => a.uncheckedValue ? Array.isArray(a.modelValue) ? a.modelValue.indexOf(a.value) > -1 : a.modelValue === a.value : a.modelValue,
      set: (_) => {
        let F = _;
        Array.isArray(a.modelValue) ? a.uncheckedValue && (F = a.modelValue, _ ? (F.indexOf(a.uncheckedValue) > -1 && F.splice(F.indexOf(a.uncheckedValue), 1), F.push(a.value)) : (F.indexOf(a.value) > -1 && F.splice(F.indexOf(a.value), 1), F.push(a.uncheckedValue))) : F = _ ? a.value : a.uncheckedValue, t("input", F), t("update:modelValue", F), t("change", F);
      }
    }), f = u(() => Array.isArray(a.modelValue) ? a.modelValue.indexOf(a.value) > -1 : JSON.stringify(a.modelValue) === JSON.stringify(a.value)), m = ye({
      plain: s(r, "value"),
      button: s(d, "value"),
      inline: s(B, "value"),
      switch: s(v, "value"),
      size: s(a, "size"),
      state: s(h, "value"),
      buttonVariant: s(a, "buttonVariant")
    }), I = Qt(m), z = ea(m), S = ta(m);
    return de(() => {
      n.value && V.value.focus();
    }), (_, F) => (c(), b("div", {
      class: x(o(I))
    }, [
      Pe(E("input", D({ id: o(T) }, _.$attrs, {
        ref_key: "input",
        ref: V,
        "onUpdate:modelValue": F[0] || (F[0] = (j) => Ee(p) ? p.value = j : null),
        class: o(z),
        type: "checkbox",
        disabled: o(g),
        required: !!e.name && !!o(y),
        name: e.name,
        form: e.form,
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledBy,
        "aria-required": e.name && o(y) ? "true" : void 0,
        value: e.value,
        indeterminate: o(l),
        onFocus: F[1] || (F[1] = (j) => k.value = !0),
        onBlur: F[2] || (F[2] = (j) => k.value = !1)
      }), null, 16, js), [
        [Ja, o(p)]
      ]),
      _.$slots.default || !o(r) ? (c(), b("label", {
        key: 0,
        for: o(T),
        class: x([o(S), { active: o(f), focus: k.value }])
      }, [
        $(_.$slots, "default")
      ], 10, Ds)) : P("", !0)
    ], 2));
  }
}), Gs = ["id"], Us = ["innerHTML"], Ws = ["textContent"], Xs = /* @__PURE__ */ C({
  __name: "BFormCheckboxGroup",
  props: {
    id: null,
    form: null,
    modelValue: { default: () => [] },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: null,
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    size: null,
    stacked: { default: !1 },
    state: { default: void 0 },
    switches: { default: !1 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e;
    i(s(a, "autofocus"));
    const l = i(s(a, "buttons")), n = i(s(a, "disabled"));
    i(s(a, "plain"));
    const r = i(s(a, "required")), d = i(s(a, "stacked")), v = a.state !== void 0 ? i(s(a, "state")) : u(() => {
    }), g = i(s(a, "switches")), B = i(s(a, "validated")), y = Te(), h = "BFormCheckbox", T = ce(s(a, "id"), "checkbox"), V = ce(s(a, "name"), "checkbox"), k = u({
      get: () => a.modelValue,
      set: (z) => {
        JSON.stringify(z) !== JSON.stringify(a.modelValue) && (t("input", z), t("update:modelValue", z), t("change", z));
      }
    }), p = u(
      () => (y.first ? Ge(y.first(), h, n.value) : []).concat(a.options.map((z) => na(z, a))).concat(y.default ? Ge(y.default(), h, n.value) : []).map((z, S) => sa(z, S, a, V, T)).map((z) => ({
        ...z,
        props: {
          switch: g.value,
          ...z.props
        }
      }))
    ), f = ye({
      required: s(r, "value"),
      ariaInvalid: s(a, "ariaInvalid"),
      state: s(v, "value"),
      validated: s(B, "value"),
      buttons: s(l, "value"),
      stacked: s(d, "value"),
      size: s(a, "size")
    }), m = aa(f), I = la(f);
    return (z, S) => (c(), b("div", D(o(m), {
      id: o(T),
      role: "group",
      class: [o(I), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      (c(!0), b(X, null, te(o(p), (_, F) => (c(), N(Ba, D({
        key: F,
        modelValue: o(k),
        "onUpdate:modelValue": S[0] || (S[0] = (j) => Ee(k) ? k.value = j : null)
      }, _.props), {
        default: L(() => [
          _.html ? (c(), b("span", {
            key: 0,
            innerHTML: _.html
          }, null, 8, Us)) : (c(), b("span", {
            key: 1,
            textContent: H(_.text)
          }, null, 8, Ws))
        ]),
        _: 2
      }, 1040, ["modelValue"]))), 128))
    ], 16, Gs));
  }
}), $a = ["input", "select", "textarea"], Ks = $a.map((e) => `${e}:not([disabled])`).join(), Js = [...$a, "a", "button", "label"], Ys = "label", Zs = "invalid-feedback", Qs = "valid-feedback", eo = "description", to = "default", ao = C({
  components: { BCol: Ie, BFormInvalidFeedback: ct, BFormRow: je, BFormText: ft, BFormValidFeedback: vt },
  props: {
    contentCols: { type: [Boolean, String, Number], required: !1 },
    contentColsLg: { type: [Boolean, String, Number], required: !1 },
    contentColsMd: { type: [Boolean, String, Number], required: !1 },
    contentColsSm: { type: [Boolean, String, Number], required: !1 },
    contentColsXl: { type: [Boolean, String, Number], required: !1 },
    description: { type: [String], required: !1 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, required: !1 },
    invalidFeedback: { type: String, required: !1 },
    label: { type: String, required: !1 },
    labelAlign: { type: [Boolean, String, Number], required: !1 },
    labelAlignLg: { type: [Boolean, String, Number], required: !1 },
    labelAlignMd: { type: [Boolean, String, Number], required: !1 },
    labelAlignSm: { type: [Boolean, String, Number], required: !1 },
    labelAlignXl: { type: [Boolean, String, Number], required: !1 },
    labelClass: { type: [Array, Object, String], required: !1 },
    labelCols: { type: [Boolean, String, Number], required: !1 },
    labelColsLg: { type: [Boolean, String, Number], required: !1 },
    labelColsMd: { type: [Boolean, String, Number], required: !1 },
    labelColsSm: { type: [Boolean, String, Number], required: !1 },
    labelColsXl: { type: [Boolean, String, Number], required: !1 },
    labelFor: { type: String, required: !1 },
    labelSize: { type: String, required: !1 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, required: !1 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e, { attrs: t }) {
    const a = i(s(e, "disabled")), l = i(s(e, "labelSrOnly")), n = i(s(e, "state")), r = i(s(e, "tooltip")), d = i(s(e, "validated")), v = i(s(e, "floating")), g = null, B = ["xs", "sm", "md", "lg", "xl"], y = (F, j) => B.reduce((A, w) => {
      const O = F[St(w, `${j}Align`)] || null;
      return O && A.push(["text", w, O].filter((K) => K).join("-")), A;
    }, []), h = (F, j) => B.reduce((A, w) => {
      let O = F[St(w, `${j}Cols`)];
      return O = O === "" ? !0 : O || !1, !tt(O) && O !== "auto" && (O = Nl(O, 0), O = O > 0 ? O : !1), O && (A[w || (tt(O) ? "col" : "cols")] = O), A;
    }, {}), T = G(), V = (F, j = null) => {
      if (pl && e.labelFor) {
        const A = Tl(`#${ml(e.labelFor)}`, T);
        if (A) {
          const w = "aria-describedby", O = (F || "").split(Re), K = (j || "").split(Re), Z = (Mt(A, w) || "").split(Re).filter((Y) => !fl(K, Y)).concat(O).filter((Y, R, se) => se.indexOf(Y) === R).filter((Y) => Y).join(" ").trim();
          Z ? Vl(A, w, Z) : wl(A, w);
        }
      }
    }, k = u(() => h(e, "content")), p = u(() => y(e, "label")), f = u(() => h(e, "label")), m = u(
      () => Object.keys(k.value).length > 0 || Object.keys(f.value).length > 0
    ), I = u(
      () => tt(n.value) ? n.value : null
    ), z = u(() => {
      const F = I.value;
      return F === !0 ? "is-valid" : F === !1 ? "is-invalid" : null;
    }), S = u(
      () => Je(t.ariaInvalid, n.value)
    );
    return ie(
      () => g,
      (F, j) => {
        F !== j && V(F, j);
      }
    ), de(() => {
      Se(() => {
        V(g);
      });
    }), {
      disabledBoolean: a,
      labelSrOnlyBoolean: l,
      stateBoolean: n,
      tooltipBoolean: r,
      validatedBoolean: d,
      floatingBoolean: v,
      ariaDescribedby: g,
      computedAriaInvalid: S,
      contentColProps: k,
      isHorizontal: m,
      labelAlignClasses: p,
      labelColProps: f,
      onLegendClick: (F) => {
        if (e.labelFor)
          return;
        const { target: j } = F, A = j ? j.tagName : "";
        if (Js.indexOf(A) !== -1)
          return;
        const w = Cl(Ks, T).filter(Sl);
        w.length === 1 && $l(w[0]);
      },
      stateClass: z
    };
  },
  render() {
    const e = this.$props, t = this.$slots, a = ce(), l = !e.labelFor;
    let n = null;
    const r = ve(Ys, {}, t) || e.label, d = r ? he("_BV_label_") : null;
    if (r || this.isHorizontal) {
      const S = l ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        r && (n = W(
          S,
          {
            class: "visually-hidden",
            id: d,
            for: e.labelFor || null
          },
          r
        )), this.isHorizontal ? n = W(Ie, this.labelColProps, { default: () => n }) : n = W("div", {}, [n]);
      else {
        const _ = {
          onClick: l ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? S : null,
          id: d,
          for: e.labelFor || null,
          tabIndex: l ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": l,
              "col-form-label": this.isHorizontal || l,
              "pt-0": !this.isHorizontal && l,
              "d-block": !this.isHorizontal && !l,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? n = W(Ie, _, { default: () => r }) : n = W(S, _, r);
      }
    }
    let v = null;
    const g = ve(Zs, {}, t) || this.invalidFeedback, B = g ? he("_BV_feedback_invalid_") : void 0;
    g && (v = W(
      ct,
      {
        ariaLive: e.feedbackAriaLive,
        id: B,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => g }
    ));
    let y = null;
    const h = ve(Qs, {}, t) || this.validFeedback, T = h ? he("_BV_feedback_valid_") : void 0;
    h && (y = W(
      vt,
      {
        ariaLive: e.feedbackAriaLive,
        id: T,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => h }
    ));
    let V = null;
    const k = ve(eo, {}, t) || this.description, p = k ? he("_BV_description_") : void 0;
    k && (V = W(
      ft,
      {
        id: p
      },
      { default: () => k }
    ));
    const f = this.ariaDescribedby = [
      p,
      this.stateBoolean === !1 ? B : null,
      this.stateBoolean === !0 ? T : null
    ].filter((S) => S).join(" ") || null, m = [
      ve(to, { ariaDescribedby: f, descriptionId: p, id: a, labelId: d }, t) || "",
      v,
      y,
      V
    ];
    !this.isHorizontal && this.floatingBoolean && m.push(n);
    let I = W(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      m
    );
    this.isHorizontal && (I = W(Ie, { ref: "content", ...this.contentColProps }, { default: () => m }));
    const z = {
      class: [
        "mb-3",
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: ce(s(e, "id")).value,
      disabled: l ? this.disabledBoolean : null,
      role: l ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      "aria-labelledby": l && this.isHorizontal ? d : null
    };
    return this.isHorizontal && !l ? W(je, z, { default: () => [n, I] }) : W(
      l ? "fieldset" : "div",
      z,
      this.isHorizontal && l ? [W(je, {}, { default: () => [n, I] })] : this.isHorizontal || !this.floatingBoolean ? [n, I] : [I]
    );
  }
}), xt = [
  "text",
  "number",
  "email",
  "password",
  "search",
  "url",
  "tel",
  "date",
  "time",
  "range",
  "color"
], lo = C({
  props: {
    ...oa,
    max: { type: [String, Number], required: !1 },
    min: { type: [String, Number], required: !1 },
    step: { type: [String, Number], required: !1 },
    type: {
      type: String,
      default: "text",
      validator: (e) => xt.includes(e)
    }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const a = u(() => {
      const T = e.type === "range", V = e.type === "color";
      return {
        "form-range": T,
        "form-control": V || !e.plaintext && !T,
        "form-control-color": V,
        "form-control-plaintext": e.plaintext && !T && !V,
        [`form-control-${e.size}`]: e.size,
        "is-valid": e.state === !0,
        "is-invalid": e.state === !1
      };
    }), l = u(
      () => xt.includes(e.type) ? e.type : "text"
    ), { input: n, computedId: r, computedAriaInvalid: d, onInput: v, onChange: g, onBlur: B, focus: y, blur: h } = ia(e, t);
    return {
      classes: a,
      localType: l,
      input: n,
      computedId: r,
      computedAriaInvalid: d,
      onInput: v,
      onChange: g,
      onBlur: B,
      focus: y,
      blur: h
    };
  }
}), no = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
function so(e, t, a, l, n, r) {
  return c(), b("input", D({
    id: e.computedId,
    ref: "input",
    class: e.classes,
    name: e.name || void 0,
    form: e.form || void 0,
    type: e.localType,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    min: e.min,
    max: e.max,
    step: e.step,
    list: e.type !== "password" ? e.list : void 0,
    "aria-required": e.required ? "true" : void 0,
    "aria-invalid": e.computedAriaInvalid
  }, e.$attrs, {
    onInput: t[0] || (t[0] = (d) => e.onInput(d)),
    onChange: t[1] || (t[1] = (d) => e.onChange(d)),
    onBlur: t[2] || (t[2] = (d) => e.onBlur(d))
  }), null, 16, no);
}
const oo = /* @__PURE__ */ fe(lo, [["render", so]]), io = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], ro = ["for"], ka = /* @__PURE__ */ C({
  __name: "BFormRadio",
  props: {
    ariaLabel: null,
    ariaLabelledBy: null,
    form: null,
    id: null,
    name: null,
    size: null,
    autofocus: { default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number], default: void 0 },
    plain: { default: !1 },
    button: { default: !1 },
    switch: { default: !1 },
    disabled: { default: !1 },
    buttonVariant: { default: "secondary" },
    inline: { default: !1 },
    required: { default: !1 },
    state: { default: void 0 },
    value: { type: [String, Boolean, Object, Number], default: !0 }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "autofocus")), n = i(s(a, "plain")), r = i(s(a, "button")), d = i(s(a, "switch")), v = i(s(a, "disabled")), g = i(s(a, "inline")), B = i(s(a, "required")), y = a.state !== void 0 ? i(s(a, "state")) : u(() => {
    }), h = ce(s(a, "id"), "form-check"), T = G(null), V = G(!1), k = u({
      get: () => Array.isArray(a.modelValue) ? a.modelValue[0] : a.modelValue,
      set: (S) => {
        const _ = S ? a.value : !1, F = Array.isArray(a.modelValue) ? [_] : _;
        t("input", F), t("change", F), t("update:modelValue", F);
      }
    }), p = u(() => Array.isArray(a.modelValue) ? (a.modelValue || []).find((S) => S === a.value) : JSON.stringify(a.modelValue) === JSON.stringify(a.value)), f = ye({
      plain: s(n, "value"),
      button: s(r, "value"),
      inline: s(g, "value"),
      switch: s(d, "value"),
      size: s(a, "size"),
      state: s(y, "value"),
      buttonVariant: s(a, "buttonVariant")
    }), m = Qt(f), I = ea(f), z = ta(f);
    return de(() => {
      l.value && T.value.focus();
    }), (S, _) => (c(), b("div", {
      class: x(o(m))
    }, [
      Pe(E("input", D({ id: o(h) }, S.$attrs, {
        ref_key: "input",
        ref: T,
        "onUpdate:modelValue": _[0] || (_[0] = (F) => Ee(k) ? k.value = F : null),
        class: o(I),
        type: "radio",
        disabled: o(v),
        required: !!e.name && !!o(B),
        name: e.name,
        form: e.form,
        "aria-label": e.ariaLabel,
        "aria-labelledby": e.ariaLabelledBy,
        value: e.value,
        "aria-required": e.name && o(B) ? !0 : void 0,
        onFocus: _[1] || (_[1] = (F) => V.value = !0),
        onBlur: _[2] || (_[2] = (F) => V.value = !1)
      }), null, 16, io), [
        [Ya, o(k)]
      ]),
      S.$slots.default || !o(n) ? (c(), b("label", {
        key: 0,
        for: o(h),
        class: x([o(z), { active: o(p), focus: V.value }])
      }, [
        $(S.$slots, "default")
      ], 10, ro)) : P("", !0)
    ], 2));
  }
}), uo = ["id"], co = ["innerHTML"], fo = ["textContent"], vo = /* @__PURE__ */ C({
  __name: "BFormRadioGroup",
  props: {
    size: null,
    form: null,
    id: null,
    name: null,
    modelValue: { type: [String, Boolean, Array, Object, Number], default: "" },
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { default: !1 },
    required: { default: !1 },
    stacked: { default: !1 },
    state: { default: void 0 },
    textField: { default: "text" },
    validated: { default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { emit: t }) {
    const a = e;
    i(s(a, "autofocus"));
    const l = i(s(a, "buttons")), n = i(s(a, "disabled"));
    i(s(a, "plain"));
    const r = i(s(a, "required")), d = i(s(a, "stacked")), v = a.state !== void 0 ? i(s(a, "state")) : u(() => {
    }), g = i(s(a, "validated")), B = Te(), y = "BFormRadio", h = ce(s(a, "id"), "radio"), T = ce(s(a, "name"), "checkbox"), V = u({
      get: () => a.modelValue,
      set: (I) => {
        t("input", I), t("update:modelValue", I), t("change", I);
      }
    }), k = u(
      () => (B.first ? Ge(B.first(), y, n.value) : []).concat(a.options.map((I) => na(I, a))).concat(B.default ? Ge(B.default(), y, n.value) : []).map((I, z) => sa(I, z, a, T, h)).map((I) => ({
        ...I
      }))
    ), p = ye({
      required: s(r, "value"),
      ariaInvalid: s(a, "ariaInvalid"),
      state: s(v, "value"),
      validated: s(g, "value"),
      buttons: s(l, "value"),
      stacked: s(d, "value"),
      size: s(a, "size")
    }), f = aa(p), m = la(p);
    return (I, z) => (c(), b("div", D(o(f), {
      id: o(h),
      role: "radiogroup",
      class: [o(m), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      (c(!0), b(X, null, te(o(k), (S, _) => (c(), N(ka, D({
        key: _,
        modelValue: o(V),
        "onUpdate:modelValue": z[0] || (z[0] = (F) => Ee(V) ? V.value = F : null)
      }, S.props), {
        default: L(() => [
          S.html ? (c(), b("span", {
            key: 0,
            innerHTML: S.html
          }, null, 8, co)) : (c(), b("span", {
            key: 1,
            textContent: H(S.text)
          }, null, 8, fo))
        ]),
        _: 2
      }, 1040, ["modelValue"]))), 128))
    ], 16, uo));
  }
}), bo = ["value", "disabled"], yt = /* @__PURE__ */ C({
  __name: "BFormSelectOption",
  props: {
    value: null,
    disabled: { default: !1 }
  },
  setup(e) {
    const a = i(s(e, "disabled"));
    return (l, n) => {
      var r;
      return c(), b("option", {
        value: (r = e.value) != null ? r : "",
        disabled: o(a)
      }, [
        $(l.$slots, "default")
      ], 8, bo);
    };
  }
}), mo = ["label"], Sa = /* @__PURE__ */ C({
  __name: "BFormSelectOptionGroup",
  props: {
    label: null,
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, a = u(
      () => pt(t.options, "BFormSelectOptionGroup", t)
    );
    return (l, n) => (c(), b("optgroup", { label: e.label }, [
      $(l.$slots, "first"),
      (c(!0), b(X, null, te(o(a), (r, d) => (c(), N(yt, D({
        key: `option_${d}`,
        value: r.value,
        disabled: r.disabled
      }, l.$attrs, {
        innerHTML: r.html || r.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      $(l.$slots, "default")
    ], 8, mo));
  }
}), go = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], po = /* @__PURE__ */ C({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { default: void 0 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    disabledField: { default: "disabled" },
    form: null,
    htmlField: { default: "html" },
    id: null,
    labelField: { default: "label" },
    multiple: { default: !1 },
    name: null,
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { default: !1 },
    required: { default: !1 },
    selectSize: { default: 0 },
    size: null,
    state: { default: void 0 },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: a }) {
    const l = e, n = i(s(l, "autofocus")), r = i(s(l, "disabled")), d = i(s(l, "multiple")), v = i(s(l, "plain")), g = i(s(l, "required")), B = l.state !== void 0 ? i(s(l, "state")) : u(() => {
    }), y = G(), h = ce(s(l, "id"), "input"), T = () => {
      Se(() => {
        var S;
        n.value && ((S = y.value) == null || S.focus());
      });
    };
    de(T), mt(T);
    const V = u(() => ({
      "form-control": v.value,
      [`form-control-${l.size}`]: l.size && v.value,
      "form-select": !v.value,
      [`form-select-${l.size}`]: l.size && !v.value,
      "is-valid": B.value === !0,
      "is-invalid": B.value === !1
    })), k = u(() => {
      if (l.selectSize || v.value)
        return l.selectSize;
    }), p = u(
      () => Je(l.ariaInvalid, B.value)
    ), f = u(
      () => pt(l.options, "BFormSelect", l)
    ), m = u({
      get() {
        return l.modelValue;
      },
      set(S) {
        a("change", S), a("update:modelValue", S), a("input", S);
      }
    });
    return t({
      blur: () => {
        var S;
        r.value || (S = y.value) == null || S.blur();
      },
      focus: () => {
        var S;
        r.value || (S = y.value) == null || S.focus();
      }
    }), (S, _) => Pe((c(), b("select", D({
      id: o(h),
      ref_key: "input",
      ref: y
    }, S.$attrs, {
      "onUpdate:modelValue": _[0] || (_[0] = (F) => Ee(m) ? m.value = F : null),
      class: o(V),
      name: e.name,
      form: e.form || void 0,
      multiple: o(d) || void 0,
      size: o(k),
      disabled: o(r),
      required: o(g),
      "aria-required": o(g) ? !0 : void 0,
      "aria-invalid": o(p)
    }), [
      $(S.$slots, "first"),
      (c(!0), b(X, null, te(o(f), (F, j) => (c(), b(X, null, [
        Array.isArray(F.options) ? (c(), N(Sa, {
          key: `option_${j}`,
          label: F.label,
          options: F.options
        }, null, 8, ["label", "options"])) : (c(), N(yt, {
          key: `option2_${j}`,
          value: F.value,
          disabled: F.disabled,
          innerHTML: F.html || F.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 256)),
      $(S.$slots, "default")
    ], 16, go)), [
      [Za, o(m)]
    ]);
  }
}), ho = ["id"], yo = ["aria-label", "aria-controls", "aria-describedby"], Ta = /* @__PURE__ */ C({
  __name: "BFormTag",
  props: {
    id: null,
    title: null,
    disabled: { default: !1 },
    noRemove: { default: !1 },
    pill: { default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "disabled")), n = i(s(a, "noRemove")), r = Te(), d = u(
      () => {
        var y, h, T;
        return (T = ((h = (y = r.default) == null ? void 0 : y.call(r)[0].children) == null ? void 0 : h.toString()) || a.title) != null ? T : "";
      }
    ), v = ce(s(a, "id")), g = u(() => `${v.value}taglabel__`), B = u(() => [
      `bg-${a.variant}`,
      {
        "text-dark": ["warning", "info", "light"].includes(a.variant),
        "rounded-pill": a.pill,
        disabled: l.value
      }
    ]);
    return (y, h) => (c(), N(q(e.tag), {
      id: o(v),
      title: o(d),
      class: x(["badge b-form-tag d-inline-flex align-items-center mw-100", o(B)]),
      "aria-labelledby": o(g)
    }, {
      default: L(() => [
        E("span", {
          id: o(g),
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          $(y.$slots, "default", {}, () => [
            Q(H(o(d)), 1)
          ])
        ], 8, ho),
        !o(l) && !o(n) ? (c(), b("button", {
          key: 0,
          "aria-keyshortcuts": "Delete",
          type: "button",
          "aria-label": e.removeLabel,
          class: x(["btn-close b-form-tag-remove", {
            "btn-close-white": !["warning", "info", "light"].includes(e.variant)
          }]),
          "aria-controls": e.id,
          "aria-describedby": o(g),
          onClick: h[0] || (h[0] = (T) => t("remove", o(d)))
        }, null, 10, yo)) : P("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), Bo = ["id"], $o = ["id", "for", "aria-live"], ko = ["id", "aria-live"], So = ["id"], To = ["aria-controls"], Co = {
  role: "group",
  class: "d-flex"
}, Vo = ["id", "disabled", "value", "type", "placeholder", "form", "required"], wo = ["disabled"], _o = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, Ao = {
  key: 0,
  class: "d-block invalid-feedback"
}, xo = {
  key: 1,
  class: "form-text text-muted"
}, Fo = {
  key: 2,
  class: "form-text text-muted"
}, Io = ["name", "value"], Oo = /* @__PURE__ */ C({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { default: !1 },
    autofocus: { default: !1 },
    disabled: { default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: null,
    inputClass: null,
    inputId: null,
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: null,
    limit: null,
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: null,
    noAddOnEnter: { default: !1 },
    noOuterFocus: { default: !1 },
    noTagRemove: { default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { default: !1 },
    required: { default: !1 },
    separator: null,
    state: { default: void 0 },
    size: null,
    tagClass: null,
    tagPills: { default: !1 },
    tagRemoveLabel: null,
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "addOnChange")), n = i(s(a, "autofocus")), r = i(s(a, "disabled")), d = i(s(a, "noAddOnEnter")), v = i(s(a, "noOuterFocus")), g = i(s(a, "noTagRemove")), B = i(s(a, "removeOnDelete")), y = i(s(a, "required")), h = a.state !== void 0 ? i(s(a, "state")) : u(() => {
    }), T = i(s(a, "tagPills")), V = G(null), k = ce(), p = u(() => a.inputId || `${k.value}input__`);
    de(() => {
      Y(), a.modelValue.length > 0 && (I.value = !0);
    }), mt(() => Y()), ie(
      () => a.modelValue,
      (U) => {
        f.value = U;
      }
    );
    const f = G(a.modelValue), m = G(""), I = G(!1), z = G(!1), S = G(""), _ = G([]), F = G([]), j = G([]), A = u(() => ({
      [`form-control-${a.size}`]: a.size,
      disabled: r.value,
      focus: z.value,
      "is-invalid": h.value === !1,
      "is-valid": h.value === !0
    })), w = u(() => f.value.includes(m.value)), O = u(
      () => m.value === "" ? !1 : !a.tagValidator(m.value)
    ), K = u(() => f.value.length === a.limit), Z = u(() => !O.value && !w.value), Y = () => {
      var U;
      n.value && ((U = V.value) == null || U.focus());
    }, R = (U) => {
      if (r.value) {
        U.target.blur();
        return;
      }
      t("focusin", U);
    }, se = (U) => {
      r.value || v.value || (z.value = !0, t("focus", U));
    }, re = (U) => {
      z.value = !1, t("blur", U);
    }, J = (U) => {
      var oe, He;
      const ee = typeof U == "string" ? U : U.target.value;
      if (I.value = !1, ((oe = a.separator) == null ? void 0 : oe.includes(ee.charAt(0))) && ee.length > 0) {
        V.value && (V.value.value = "");
        return;
      }
      if (m.value = ee, (He = a.separator) != null && He.includes(ee.charAt(ee.length - 1))) {
        ne(ee.slice(0, ee.length - 1));
        return;
      }
      _.value = a.tagValidator(ee) && !w.value ? [ee] : [], F.value = a.tagValidator(ee) ? [] : [ee], j.value = w.value ? [ee] : [], t("tag-state", _.value, F.value, j.value);
    }, M = (U) => {
      l.value && (J(U), w.value || ne(m.value));
    }, ue = (U) => {
      if (U.key === "Enter" && !d.value) {
        ne(m.value);
        return;
      }
      (U.key === "Backspace" || U.key === "Delete") && B.value && m.value === "" && I.value && f.value.length > 0 ? pe(f.value[f.value.length - 1]) : I.value = !0;
    }, ne = (U) => {
      var oe;
      if (U = (U || m.value).trim(), U === "" || w.value || !a.tagValidator(U) || a.limit && K.value)
        return;
      const ee = [...a.modelValue, U];
      m.value = "", I.value = !0, t("update:modelValue", ee), t("input", ee), (oe = V.value) == null || oe.focus();
    }, pe = (U) => {
      var oe;
      const ee = f.value.indexOf((oe = U == null ? void 0 : U.toString()) != null ? oe : "");
      S.value = f.value.splice(ee, 1).toString(), t("update:modelValue", f.value);
    }, Ze = u(() => {
      const {
        addButtonText: U,
        addButtonVariant: ee,
        duplicateTagText: oe,
        inputAttrs: He,
        form: $t,
        inputType: za,
        invalidTagText: La,
        limitTagsText: Pa,
        limit: Ea,
        placeholder: Ha,
        separator: qa,
        size: Ra,
        tagClass: ja,
        tagRemoveLabel: Da,
        tagVariant: Ma
      } = a;
      return {
        addButtonText: U,
        addButtonVariant: ee,
        addTag: ne,
        disableAddButton: Z,
        disabled: r.value,
        duplicateTagText: oe,
        duplicateTags: j,
        form: $t,
        inputAttrs: {
          ...He,
          disabled: r.value,
          form: $t,
          id: p,
          value: m
        },
        inputHandlers: {
          input: J,
          keydown: ue,
          change: M
        },
        inputId: p,
        inputType: za,
        invalidTagText: La,
        invalidTags: F,
        isDuplicate: w,
        isInvalid: O,
        isLimitReached: K,
        limitTagsText: Pa,
        limit: Ea,
        noTagRemove: g.value,
        placeholder: Ha,
        removeTag: pe,
        required: y.value,
        separator: qa,
        size: Ra,
        state: h.value,
        tagClass: ja,
        tagPills: T.value,
        tagRemoveLabel: Da,
        tagVariant: Ma,
        tags: f
      };
    });
    return (U, ee) => (c(), b("div", {
      id: o(k),
      class: x(["b-form-tags form-control h-auto", o(A)]),
      role: "group",
      tabindex: "-1",
      onFocusin: R,
      onFocusout: ee[1] || (ee[1] = (oe) => U.$emit("focusout", oe))
    }, [
      E("output", {
        id: `${o(k)}selected_tags__`,
        class: "visually-hidden",
        role: "status",
        for: o(p),
        "aria-live": z.value ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, H(f.value.join(", ")), 9, $o),
      E("div", {
        id: `${o(k)}removed_tags__`,
        role: "status",
        "aria-live": z.value ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + H(e.tagRemovedLabel) + ") " + H(S.value), 9, ko),
      $(U.$slots, "default", Oe(Ne(o(Ze))), () => [
        E("ul", {
          id: `${o(k)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (c(!0), b(X, null, te(f.value, (oe) => (c(), N(Ta, {
            key: oe,
            class: x(e.tagClass),
            tag: "li",
            variant: e.tagVariant,
            pill: o(T),
            onRemove: pe
          }, {
            default: L(() => [
              Q(H(oe), 1)
            ]),
            _: 2
          }, 1032, ["class", "variant", "pill"]))), 128)),
          E("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${o(k)}tag_list__`
          }, [
            E("div", Co, [
              E("input", D({
                id: o(p),
                ref_key: "input",
                ref: V,
                disabled: o(r),
                value: m.value,
                type: e.inputType,
                placeholder: e.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, e.inputAttrs, {
                form: e.form,
                required: o(y),
                onInput: J,
                onChange: M,
                onKeydown: ue,
                onFocus: se,
                onBlur: re
              }), null, 16, Vo),
              o(Z) ? (c(), b("button", {
                key: 0,
                type: "button",
                class: x(["btn b-form-tags-button py-0", [
                  `btn-${e.addButtonVariant}`,
                  {
                    "disabled invisible": m.value.length === 0
                  },
                  e.inputClass
                ]]),
                style: { "font-size": "90%" },
                disabled: o(r) || m.value.length === 0 || o(K),
                onClick: ee[0] || (ee[0] = (oe) => ne(m.value))
              }, [
                $(U.$slots, "add-button-text", {}, () => [
                  Q(H(e.addButtonText), 1)
                ])
              ], 10, wo)) : P("", !0)
            ])
          ], 8, To)
        ], 8, So),
        E("div", _o, [
          o(O) ? (c(), b("div", Ao, H(e.invalidTagText) + ": " + H(m.value), 1)) : P("", !0),
          o(w) ? (c(), b("small", xo, H(e.duplicateTagText) + ": " + H(m.value), 1)) : P("", !0),
          f.value.length === e.limit ? (c(), b("small", Fo, "Tag limit reached")) : P("", !0)
        ])
      ]),
      e.name ? (c(!0), b(X, { key: 0 }, te(f.value, (oe) => (c(), b("input", {
        key: oe,
        type: "hidden",
        name: e.name,
        value: oe
      }, null, 8, Io))), 128)) : P("", !0)
    ], 42, Bo));
  }
}), No = C({
  props: {
    ...oa,
    noResize: { type: [Boolean, String], default: !1 },
    rows: { type: [String, Number], required: !1, default: 2 },
    wrap: { type: String, default: "soft" }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { emit: t }) {
    const a = i(s(e, "noResize")), l = u(() => ({
      "form-control": !e.plaintext,
      "form-control-plaintext": e.plaintext,
      [`form-control-${e.size}`]: e.size,
      "is-valid": e.state === !0,
      "is-invalid": e.state === !1
    })), n = u(
      () => a.value ? { resize: "none" } : void 0
    ), { input: r, computedId: d, computedAriaInvalid: v, onInput: g, onChange: B, onBlur: y, focus: h, blur: T } = ia(e, t);
    return {
      input: r,
      computedId: d,
      computedAriaInvalid: v,
      onInput: g,
      onChange: B,
      onBlur: y,
      focus: h,
      blur: T,
      classes: l,
      computedStyles: n
    };
  }
}), zo = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
function Lo(e, t, a, l, n, r) {
  return c(), b("textarea", D({
    id: e.computedId,
    ref: "input",
    class: e.classes,
    name: e.name || void 0,
    form: e.form || void 0,
    disabled: e.disabled,
    placeholder: e.placeholder,
    required: e.required,
    autocomplete: e.autocomplete || void 0,
    readonly: e.readonly || e.plaintext,
    "aria-required": e.required ? "true" : void 0,
    "aria-invalid": e.computedAriaInvalid,
    rows: e.rows,
    style: e.computedStyles,
    wrap: e.wrap || void 0
  }, e.$attrs, {
    onInput: t[0] || (t[0] = (d) => e.onInput(d)),
    onChange: t[1] || (t[1] = (d) => e.onChange(d)),
    onBlur: t[2] || (t[2] = (d) => e.onBlur(d))
  }), null, 16, zo);
}
const Po = /* @__PURE__ */ fe(No, [["render", Lo]]), Eo = /* @__PURE__ */ C({
  __name: "BImg",
  props: {
    alt: { default: void 0 },
    blank: { default: !1 },
    blankColor: { default: "transparent" },
    block: { default: !1 },
    center: { default: !1 },
    fluid: { default: !1 },
    fluidGrow: { default: !1 },
    height: null,
    left: { default: !1 },
    right: { default: !1 },
    rounded: { type: [Boolean, String], default: !1 },
    sizes: null,
    src: null,
    srcset: null,
    thumbnail: { default: !1 },
    width: null
  },
  setup(e) {
    const t = e, a = i(s(t, "blank")), l = i(s(t, "block")), n = i(s(t, "center")), r = i(s(t, "fluid")), d = i(s(t, "fluidGrow")), v = i(s(t, "left")), g = i(s(t, "right")), B = i(s(t, "thumbnail")), y = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', h = (p, f, m) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      y.replace("%{w}", String(p)).replace("%{h}", String(f)).replace("%{f}", m)
    )}`, T = u(() => {
      let p = t.src, f = (typeof t.width == "number" ? t.width : parseInt(t.width, 10)) || void 0, m = (typeof t.height == "number" ? t.height : parseInt(t.height, 10)) || void 0, I = "";
      typeof t.srcset == "string" ? I = t.srcset.split(",").filter((S) => S).join(",") : Array.isArray(t.srcset) && (I = t.srcset.filter((S) => S).join(","));
      let z = "";
      return typeof t.sizes == "string" ? z = t.sizes.split(",").filter((S) => S).join(",") : Array.isArray(t.sizes) && (z = t.sizes.filter((S) => S).join(",")), a.value && (!m && f ? m = f : !f && m && (f = m), !f && !m && (f = 1, m = 1), p = h(f, m, t.blankColor || "transparent"), I = "", z = ""), {
        src: p,
        alt: t.alt,
        width: f || void 0,
        height: m || void 0,
        srcset: I || void 0,
        sizes: z || void 0
      };
    }), V = u(
      () => v.value ? "float-start" : g.value ? "float-end" : n.value ? "mx-auto" : void 0
    ), k = u(() => ({
      "img-thumbnail": B.value,
      "img-fluid": r.value || d.value,
      "w-100": d.value,
      rounded: t.rounded === "" || t.rounded === !0,
      [`rounded-${t.rounded}`]: typeof t.rounded == "string" && t.rounded !== "",
      [`${V.value}`]: V.value !== void 0,
      "d-block": l.value || n.value
    }));
    return (p, f) => (c(), b("img", D({ class: o(k) }, o(T)), null, 16));
  }
}), Ho = {
  key: 0,
  class: "input-group-text"
}, qo = { key: 0 }, Ro = ["innerHTML"], jo = {
  key: 0,
  class: "input-group-text"
}, Do = { key: 0 }, Mo = ["innerHTML"], Go = /* @__PURE__ */ C({
  __name: "BInputGroup",
  props: {
    append: null,
    appendHtml: null,
    id: null,
    prepend: null,
    prependHtml: null,
    size: null,
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = u(() => ({
      "input-group-sm": t.size === "sm",
      "input-group-lg": t.size === "lg"
    })), l = u(() => !!t.append || !!t.appendHtml), n = u(() => !!t.prepend || !!t.prependHtml), r = u(() => !!t.appendHtml), d = u(() => !!t.prependHtml);
    return (v, g) => (c(), N(q(e.tag), {
      id: e.id,
      class: x(["input-group", o(a)]),
      role: "group"
    }, {
      default: L(() => [
        $(v.$slots, "prepend", {}, () => [
          o(n) ? (c(), b("span", Ho, [
            o(d) ? P("", !0) : (c(), b("span", qo, H(e.prepend), 1)),
            o(d) ? (c(), b("span", {
              key: 1,
              innerHTML: e.prependHtml
            }, null, 8, Ro)) : P("", !0)
          ])) : P("", !0)
        ]),
        $(v.$slots, "default"),
        $(v.$slots, "append", {}, () => [
          o(l) ? (c(), b("span", jo, [
            o(r) ? P("", !0) : (c(), b("span", Do, H(e.append), 1)),
            o(r) ? (c(), b("span", {
              key: 1,
              innerHTML: e.appendHtml
            }, null, 8, Mo)) : P("", !0)
          ])) : P("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Ca = /* @__PURE__ */ C({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, a) => (c(), N(q(e.tag), { class: "input-group-text" }, {
      default: L(() => [
        $(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Bt = /* @__PURE__ */ C({
  __name: "BInputGroupAddon",
  props: {
    append: { default: !1 },
    id: null,
    isText: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = i(s(t, "append")), l = i(s(t, "isText")), n = u(() => ({
      "input-group-append": a.value,
      "input-group-prepend": !a.value
    }));
    return (r, d) => (c(), N(q(e.tag), {
      id: e.id,
      class: x(["d-flex", o(n)])
    }, {
      default: L(() => [
        o(l) ? (c(), N(Ca, { key: 0 }, {
          default: L(() => [
            $(r.$slots, "default")
          ]),
          _: 3
        })) : $(r.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Uo = /* @__PURE__ */ C({
  __name: "BInputGroupAppend",
  props: {
    id: null,
    isText: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const a = i(s(e, "isText"));
    return (l, n) => (c(), N(Bt, {
      id: e.id,
      "is-text": o(a),
      tag: e.tag,
      append: ""
    }, {
      default: L(() => [
        $(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "is-text", "tag"]));
  }
}), Wo = /* @__PURE__ */ C({
  __name: "BInputGroupPrepend",
  props: {
    id: null,
    isText: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const a = i(s(e, "isText"));
    return (l, n) => (c(), N(Bt, {
      id: e.id,
      "is-text": o(a),
      tag: e.tag,
      append: !1
    }, {
      default: L(() => [
        $(l.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "is-text", "tag"]));
  }
}), Va = Symbol(), Xo = /* @__PURE__ */ C({
  __name: "BListGroup",
  props: {
    flush: { default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, a = i(s(t, "flush")), l = i(s(t, "numbered")), n = u(() => {
      const d = a.value ? !1 : t.horizontal;
      return {
        "list-group-flush": a.value,
        "list-group-horizontal": d === !0,
        [`list-group-horizontal-${d}`]: typeof d == "string",
        "list-group-numbered": l.value
      };
    }), r = u(() => l.value === !0 ? "ol" : t.tag);
    return Fe(Va, {
      numbered: l.value
    }), (d, v) => (c(), N(q(o(r)), {
      class: x(["list-group", o(n)])
    }, {
      default: L(() => [
        $(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ko = /* @__PURE__ */ C({
  __name: "BListGroupItem",
  props: {
    action: { default: !1 },
    active: { default: !1 },
    button: { default: !1 },
    disabled: { default: !1 },
    href: null,
    tag: { default: "div" },
    target: { default: "_self" },
    to: null,
    variant: null
  },
  setup(e) {
    const t = e, a = i(s(t, "action")), l = i(s(t, "active")), n = i(s(t, "button")), r = i(s(t, "disabled")), d = Pt(), v = Be(Va, null), g = u(() => !n.value && (!!t.href || !!t.to)), B = u(
      () => v != null && v.numbered ? "li" : n.value ? "button" : g.value ? be : t.tag
    ), y = u(() => {
      const T = a.value || g.value || n.value || ["a", "router-link", "button", "b-link"].includes(t.tag);
      return {
        [`list-group-item-${t.variant}`]: t.variant,
        "list-group-item-action": T,
        active: l.value,
        disabled: r.value
      };
    }), h = u(() => {
      const T = {};
      return n.value && ((!d || !d.type) && (T.type = "button"), r.value && (T.disabled = !0)), T;
    });
    return (T, V) => (c(), N(q(o(B)), D({
      class: ["list-group-item", o(y)],
      "aria-current": o(l) ? !0 : null,
      "aria-disabled": o(r) ? !0 : null,
      target: o(g) ? e.target : null,
      href: o(n) ? null : e.href,
      to: o(n) ? null : e.to
    }, o(h)), {
      default: L(() => [
        $(T.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), Jo = ["id"], Yo = ["aria-label"], Zo = {
  inheritAttrs: !1
}, Qo = /* @__PURE__ */ C({
  ...Zo,
  __name: "BModal",
  props: {
    bodyBgVariant: null,
    bodyClass: null,
    bodyTextVariant: null,
    busy: { default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { default: !1 },
    contentClass: null,
    dialogClass: null,
    footerBgVariant: null,
    footerBorderVariant: null,
    footerClass: null,
    footerTextVariant: null,
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: null,
    headerBorderVariant: null,
    headerClass: null,
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { default: !1 },
    headerTextVariant: null,
    hideBackdrop: { default: !1 },
    hideFooter: { default: !1 },
    hideHeader: { default: !1 },
    hideHeaderClose: { default: !1 },
    id: null,
    modalClass: null,
    modelValue: { default: !1 },
    noCloseOnBackdrop: { default: !1 },
    noCloseOnEsc: { default: !1 },
    noFade: { default: !1 },
    noFocus: { default: !1 },
    okDisabled: { default: !1 },
    okOnly: { default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { default: !1 },
    show: { default: !1 },
    size: null,
    title: null,
    titleClass: null,
    titleSrOnly: { default: !1 },
    titleTag: { default: "h5" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "ok", "cancel"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "busy")), n = i(s(a, "cancelDisabled")), r = i(s(a, "centered")), d = i(s(a, "headerCloseWhite")), v = i(s(a, "hideBackdrop")), g = i(s(a, "hideFooter")), B = i(s(a, "hideHeader")), y = i(s(a, "hideHeaderClose")), h = i(s(a, "modelValue")), T = i(s(a, "noCloseOnBackdrop")), V = i(s(a, "noCloseOnEsc")), k = i(s(a, "noFade")), p = i(s(a, "noFocus")), f = i(s(a, "okDisabled")), m = i(s(a, "okOnly")), I = i(s(a, "scrollable")), z = i(s(a, "show")), S = i(s(a, "titleSrOnly")), _ = Te(), F = G(), j = G(), A = u(() => [
      {
        fade: !k.value,
        show: z.value
      },
      a.modalClass
    ]), w = u(() => [
      {
        "modal-fullscreen": typeof a.fullscreen == "boolean" ? a.fullscreen : !1,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string" ? a.fullscreen : !1,
        [`modal-${a.size}`]: a.size,
        "modal-dialog-centered": r.value,
        "modal-dialog-scrollable": I.value
      },
      a.dialogClass
    ]), O = u(() => [
      {
        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant,
        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant
      },
      a.bodyClass
    ]), K = u(() => [
      {
        [`bg-${a.headerBgVariant}`]: a.headerBgVariant,
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant,
        [`text-${a.headerTextVariant}`]: a.headerTextVariant
      },
      a.headerClass
    ]), Z = u(() => [
      {
        [`bg-${a.footerBgVariant}`]: a.footerBgVariant,
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant,
        [`text-${a.footerTextVariant}`]: a.footerTextVariant
      },
      a.footerClass
    ]), Y = u(() => [
      {
        ["visually-hidden"]: S.value
      },
      a.titleClass
    ]), R = u(() => !!_["header-close"]), se = u(() => [
      {
        ["btn-close-content"]: R.value,
        ["d-flex"]: R.value,
        ["btn-close-white"]: !R.value && d.value
      }
    ]), re = u(() => n.value || l.value), J = u(() => f.value || l.value);
    return ae(F, "shown.bs.modal", (M) => t("shown", M)), ae(F, "hidden.bs.modal", (M) => t("hidden", M)), ae(F, "hidePrevented.bs.modal", (M) => t("hide-prevented", M)), ae(F, "show.bs.modal", (M) => {
      t("show", M), M.defaultPrevented || t("update:modelValue", !0);
    }), ae(F, "hide.bs.modal", (M) => {
      t("hide", M), M.defaultPrevented || t("update:modelValue", !1);
    }), de(() => {
      var M;
      j.value = new il(F.value, {
        backdrop: v.value ? !1 : T.value ? "static" : !v.value,
        keyboard: !V.value,
        focus: !p.value
      }), h.value && ((M = j.value) == null || M.show());
    }), ie(
      () => a.noCloseOnBackdrop,
      (M) => {
        j.value._config.backdrop = a.hideBackdrop ? !1 : M ? "static" : !a.hideBackdrop;
      }
    ), ie(
      () => a.noCloseOnEsc,
      (M) => {
        j.value._config.keyboard = !M;
      }
    ), ie(
      () => h.value,
      (M) => {
        var ue, ne;
        M ? (ue = j.value) == null || ue.show() : (ne = j.value) == null || ne.hide();
      }
    ), (M, ue) => (c(), N(Qa, { to: "body" }, [
      E("div", D({
        id: e.id,
        ref_key: "element",
        ref: F,
        class: ["modal", o(A)],
        tabindex: "-1"
      }, M.$attrs), [
        E("div", {
          class: x(["modal-dialog", o(w)])
        }, [
          E("div", {
            class: x(["modal-content", e.contentClass])
          }, [
            o(B) ? P("", !0) : (c(), b("div", {
              key: 0,
              class: x(["modal-header", o(K)])
            }, [
              (c(), N(q(e.titleTag), {
                class: x(["modal-title", o(Y)])
              }, {
                default: L(() => [
                  $(M.$slots, "title", {}, () => [
                    Q(H(e.title), 1)
                  ])
                ]),
                _: 3
              }, 8, ["class"])),
              o(y) ? P("", !0) : (c(), b("button", {
                key: 0,
                type: "button",
                class: x(["btn-close", o(se)]),
                "data-bs-dismiss": "modal",
                "aria-label": e.headerCloseLabel
              }, [
                $(M.$slots, "header-close")
              ], 10, Yo))
            ], 2)),
            E("div", {
              class: x(["modal-body", o(O)])
            }, [
              $(M.$slots, "default")
            ], 2),
            o(g) ? P("", !0) : (c(), b("div", {
              key: 1,
              class: x(["modal-footer", o(Z)])
            }, [
              $(M.$slots, "footer", {}, () => [
                o(m) ? P("", !0) : (c(), N(Le, {
                  key: 0,
                  type: "button",
                  class: "btn",
                  "data-bs-dismiss": "modal",
                  disabled: o(re),
                  size: e.buttonSize,
                  variant: e.cancelVariant,
                  onClick: ue[0] || (ue[0] = (ne) => M.$emit("cancel"))
                }, {
                  default: L(() => [
                    Q(H(e.cancelTitle), 1)
                  ]),
                  _: 1
                }, 8, ["disabled", "size", "variant"])),
                ge(Le, {
                  type: "button",
                  class: "btn",
                  "data-bs-dismiss": "modal",
                  disabled: o(J),
                  size: e.buttonSize,
                  variant: e.okVariant,
                  onClick: ue[1] || (ue[1] = (ne) => M.$emit("ok"))
                }, {
                  default: L(() => [
                    Q(H(e.okTitle), 1)
                  ]),
                  _: 1
                }, 8, ["disabled", "size", "variant"])
              ])
            ], 2))
          ], 2)
        ], 2)
      ], 16, Jo)
    ]));
  }
}), ei = /* @__PURE__ */ C({
  __name: "BNav",
  props: {
    align: null,
    cardHeader: { default: !1 },
    fill: { default: !1 },
    justified: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tabs: { default: !1 },
    tag: { default: "ul" },
    vertical: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(s(t, "cardHeader")), l = i(s(t, "fill")), n = i(s(t, "justified")), r = i(s(t, "pills")), d = i(s(t, "small")), v = i(s(t, "tabs")), g = i(s(t, "vertical")), B = u(() => ({
      "nav-tabs": v.value,
      "nav-pills": r.value && !v.value,
      "card-header-tabs": !g.value && a.value && v.value,
      "card-header-pills": !g.value && a.value && r.value && !v.value,
      "flex-column": g.value,
      "nav-fill": !g.value && l.value,
      "nav-justified": !g.value && n.value,
      [`justify-content-${t.align}`]: !g.value && t.align !== void 0,
      small: d.value
    }));
    return (y, h) => (c(), N(q(e.tag), {
      class: x(["nav", o(B)])
    }, {
      default: L(() => [
        $(y.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), ti = /* @__PURE__ */ C({
  __name: "BNavForm",
  props: {
    role: null,
    id: null,
    floating: { default: !1 },
    novalidate: { default: !1 },
    validated: { default: !1 }
  },
  setup(e) {
    const t = e, a = u(() => ({
      floating: t.floating,
      role: t.role,
      id: t.id,
      novalidate: t.novalidate,
      validated: t.validated
    }));
    return (l, n) => (c(), N(ya, D(o(a), { class: "d-flex" }), {
      default: L(() => [
        $(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), ai = Ye(Ce, ["event", "routerTag"]), li = C({
  components: { BLink: be },
  props: {
    ...ai
  },
  setup(e) {
    return { disabledBoolean: i(s(e, "disabled")) };
  }
}), ni = { class: "nav-item" };
function si(e, t, a, l, n, r) {
  const d = We("b-link");
  return c(), b("li", ni, [
    ge(d, D({ class: "nav-link" }, e.$props, {
      tabindex: e.disabledBoolean ? -1 : void 0,
      "aria-disabled": e.disabledBoolean ? !0 : void 0
    }), {
      default: L(() => [
        $(e.$slots, "default")
      ]),
      _: 3
    }, 16, ["tabindex", "aria-disabled"])
  ]);
}
const oi = /* @__PURE__ */ fe(li, [["render", si]]), ii = { class: "nav-item dropdown" }, ri = /* @__PURE__ */ C({
  __name: "BNavItemDropdown",
  props: {
    id: null,
    text: null,
    size: null,
    offset: null,
    autoClose: { type: [Boolean, String], default: !0 },
    dark: { type: Boolean, default: !1 },
    dropleft: { type: Boolean, default: !1 },
    dropright: { type: Boolean, default: !1 },
    dropup: { type: Boolean, default: !1 },
    right: { type: Boolean, default: !1 },
    left: { type: [Boolean, String], default: !1 },
    split: { type: Boolean, default: !1 },
    splitVariant: null,
    noCaret: { type: Boolean, default: !1 },
    variant: { default: "link" }
  },
  setup(e) {
    return (t, a) => (c(), b("li", ii, [
      ge(ha, Oe(Ne(t.$props)), el({ _: 2 }, [
        te(t.$slots, (l, n) => ({
          name: n,
          fn: L((r) => [
            $(t.$slots, n, Oe(Ne(r || {})))
          ])
        }))
      ]), 1040)
    ]));
  }
}), ui = {}, di = { class: "navbar-text" };
function ci(e, t) {
  return c(), b("li", di, [
    $(e.$slots, "default")
  ]);
}
const fi = /* @__PURE__ */ fe(ui, [["render", ci]]), vi = /* @__PURE__ */ C({
  __name: "BNavbar",
  props: {
    fixed: null,
    print: { default: !1 },
    sticky: null,
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    dark: { default: !1 },
    variant: null,
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, a = i(s(t, "print")), l = i(s(t, "dark")), n = u(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), r = u(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
    ), d = u(
      () => t.container === !1 ? void 0 : t.container === !0 ? "container" : `container-${t.container}`
    ), v = u(() => ({
      "d-print": a.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": l.value,
      [`bg-${t.variant}`]: t.variant !== void 0,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${r.value}`]: r.value !== void 0
    }));
    return (g, B) => (c(), N(q(e.tag), {
      class: x(["navbar", o(v)]),
      role: o(n)
    }, {
      default: L(() => [
        e.container !== !1 ? (c(), b("div", {
          key: 0,
          class: x(o(d))
        }, [
          $(g.$slots, "default")
        ], 2)) : $(g.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Ft = Ye(Ce, ["event", "routerTag"]), bi = C({
  components: {
    BLink: be
  },
  props: {
    tag: { type: String, default: "div" },
    ...Ft
  },
  setup(e) {
    const t = u(() => ze(e)), a = u(() => t.value ? be : e.tag);
    return {
      props: t.value ? Zt(Ft, e) : {},
      computedTag: a
    };
  }
});
function mi(e, t, a, l, n, r) {
  return c(), N(q(e.computedTag), D({ class: "navbar-brand" }, e.props), {
    default: L(() => [
      $(e.$slots, "default")
    ]),
    _: 3
  }, 16);
}
const gi = /* @__PURE__ */ fe(bi, [["render", mi]]), pi = /* @__PURE__ */ C({
  __name: "BNavbarNav",
  props: {
    align: null,
    fill: { default: !1 },
    justified: { default: !1 },
    small: { default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, a = i(s(t, "fill")), l = i(s(t, "justified")), n = i(s(t, "small")), r = u(() => ({
      "nav-fill": a.value,
      "nav-justified": l.value,
      [`justify-content-${t.align}`]: t.align !== void 0,
      small: n.value
    }));
    return (d, v) => (c(), b("ul", {
      class: x(["navbar-nav", o(r)])
    }, [
      $(d.$slots, "default")
    ], 2));
  }
}), hi = {
  mounted(e, t) {
    let a = t.value;
    Object.keys(t.modifiers).length > 0 && ([a] = Object.keys(t.modifiers)), e.setAttribute("data-bs-toggle", "modal"), e.setAttribute("data-bs-target", `#${a}`);
  }
}, yi = {
  mounted(e, t) {
    let a = "right";
    const l = [];
    t.modifiers.left ? a = "left" : t.modifiers.right ? a = "right" : t.modifiers.bottom ? a = "bottom" : t.modifiers.top && (a = "top"), t.modifiers.manual ? l.push("manual") : (t.modifiers.click && l.push("click"), t.modifiers.hover && l.push("hover"), t.modifiers.focus && l.push("focus")), e.setAttribute("data-bs-toggle", "popover"), new st(e, {
      trigger: l.length === 0 ? "click" : l.join(" "),
      placement: a,
      content: t.value
    });
  },
  unmounted(e) {
    const t = st.getInstance(e);
    t == null || t.dispose();
  }
}, Bi = (e) => {
  if (e.manual)
    return "manual";
  const t = [];
  return e.click && t.push("click"), e.hover && t.push("hover"), e.focus && t.push("focus"), t.length > 0 ? t.join(" ") : "hover focus";
}, $i = (e) => e.left ? "left" : e.right ? "right" : e.bottom ? "bottom" : "top", ki = (e) => e != null && e.delay ? e.delay : 0, Si = {
  beforeMount(e, t) {
    e.setAttribute("data-bs-toggle", "tooltip");
    const a = /<("[^"]*"|'[^']*'|[^'">])*>/.test(e.title), l = Bi(t.modifiers), n = $i(t.modifiers), r = ki(t.value), d = e.getAttribute("title");
    new Qe(e, {
      trigger: l,
      placement: n,
      delay: r,
      html: a
    }), d && e.setAttribute("data-bs-original-title", d);
  },
  updated(e) {
    const t = e.getAttribute("title"), a = e.getAttribute("data-bs-original-title"), l = Qe.getInstance(e);
    e.removeAttribute("title"), t && t !== a && (l == null || l.setContent({ ".tooltip-inner": t }), e.setAttribute("data-bs-original-title", t));
  },
  unmounted(e) {
    const t = Qe.getInstance(e);
    t == null || t.dispose();
  }
}, De = /* @__PURE__ */ new Map(), wa = (e) => {
  if (De.has(e)) {
    const t = De.get(e);
    t && t.stop && t.stop(), De.delete(e);
  }
}, It = (e, t) => {
  const a = {
    margin: "0px",
    once: !1,
    callback: t.value
  };
  Object.keys(t.modifiers).forEach((n) => {
    Number.isInteger(n) ? a.margin = `${n}px` : n.toLowerCase() === "once" && (a.once = !0);
  }), wa(e);
  const l = new Ci(
    e,
    a.margin,
    a.once,
    a.callback,
    t.instance
  );
  De.set(e, l);
}, Ti = {
  beforeMount(e, t) {
    It(e, t);
  },
  updated(e, t) {
    It(e, t);
  },
  unmounted(e) {
    wa(e);
  }
};
class Ci {
  constructor(t, a, l, n, r) {
    le(this, "element");
    le(this, "margin");
    le(this, "once");
    le(this, "callback");
    le(this, "instance");
    le(this, "observer");
    le(this, "doneOnce");
    le(this, "visible");
    this.element = t, this.margin = a, this.once = l, this.callback = n, this.instance = r, this.createObserver();
  }
  createObserver() {
    if (this.observer && this.stop(), !(this.doneOnce || typeof this.callback != "function")) {
      try {
        this.observer = new IntersectionObserver(this.handler.bind(this), {
          root: null,
          rootMargin: this.margin,
          threshold: 0
        });
      } catch {
        console.error("Intersection Observer not supported"), this.doneOnce = !0, this.observer = void 0, this.callback(null);
        return;
      }
      this.instance.$nextTick(() => {
        this.observer && this.observer.observe(this.element);
      });
    }
  }
  handler(t) {
    const [a] = t, l = Boolean(a.isIntersecting || a.intersectionRatio > 0);
    l !== this.visible && (this.visible = l, this.callback(l), this.once && this.visible && (this.doneOnce = !0, this.stop()));
  }
  stop() {
    this.observer && this.observer.disconnect(), this.observer = null;
  }
}
const Vi = {
  mounted(e, t) {
    t.value !== !1 && e.focus();
  }
}, wi = {
  BModal: hi,
  BPopover: yi,
  BToggle: ht,
  BTooltip: Si,
  BVisible: Ti,
  focus: Vi
}, _i = /* @__PURE__ */ E("span", { class: "navbar-toggler-icon" }, null, -1), Ai = /* @__PURE__ */ C({
  __name: "BNavbarToggle",
  props: {
    disabled: { default: !1 },
    label: { default: "Toggle navigation" },
    target: null
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "disabled")), n = u(() => ({
      disabled: l.value,
      "aria-label": a.label
    })), r = u(() => ({
      disabled: l.value
    })), d = () => {
      l.value || t("click");
    };
    return (v, g) => Pe((c(), b("button", D({
      class: ["navbar-toggler", o(r)],
      type: "button"
    }, o(n), { onClick: d }), [
      $(v.$slots, "default", {}, () => [
        _i
      ])
    ], 16)), [
      [o(ht), o(l) ? void 0 : e.target]
    ]);
  }
}), xi = ["data-bs-backdrop", "data-bs-scroll"], Fi = { class: "offcanvas-header" }, Ii = {
  id: "offcanvasLabel",
  class: "offcanvas-title"
}, Oi = ["aria-label"], Ni = { class: "offcanvas-body" }, zi = /* @__PURE__ */ C({
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { default: !1 },
    bodyScrolling: { default: !1 },
    backdrop: { default: !0 },
    placement: { default: "start" },
    title: null
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "modelValue")), n = i(s(a, "bodyScrolling")), r = i(s(a, "backdrop")), d = G(), v = G();
    ae(d, "shown.bs.offcanvas", () => t("shown")), ae(d, "hidden.bs.offcanvas", () => t("hidden")), ae(d, "show.bs.offcanvas", () => {
      t("show"), t("update:modelValue", !0);
    }), ae(d, "hide.bs.offcanvas", () => {
      t("hide"), t("update:modelValue", !1);
    }), de(() => {
      var B;
      v.value = new rl(d.value), l.value && ((B = v.value) == null || B.show(d.value));
    });
    const g = u(() => ({
      [`offcanvas-${a.placement}`]: a.placement
    }));
    return ie(
      () => l.value,
      (B) => {
        var y, h;
        B ? (y = v.value) == null || y.show(d.value) : (h = v.value) == null || h.hide();
      }
    ), (B, y) => (c(), b("div", {
      ref_key: "element",
      ref: d,
      class: x(["offcanvas", o(g)]),
      tabindex: "-1",
      "aria-labelledby": "offcanvasLabel",
      "data-bs-backdrop": o(r),
      "data-bs-scroll": o(n)
    }, [
      E("div", Fi, [
        E("h5", Ii, [
          $(B.$slots, "title", {}, () => [
            Q(H(e.title), 1)
          ])
        ]),
        E("button", {
          type: "button",
          class: "btn-close text-reset",
          "data-bs-dismiss": "offcanvas",
          "aria-label": e.dismissLabel
        }, null, 8, Oi)
      ]),
      E("div", Ni, [
        $(B.$slots, "default")
      ])
    ], 10, xi));
  }
}), _a = {
  name: "",
  enterActiveClass: "",
  enterToClass: "",
  leaveActiveClass: "",
  leaveToClass: "showing",
  enterFromClass: "showing",
  leaveFromClass: ""
}, Li = {
  ..._a,
  enterActiveClass: "fade showing",
  leaveActiveClass: "fade showing"
}, Ue = C({
  props: {
    appear: { type: [Boolean, String], default: !1 },
    mode: { type: String, required: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    transProps: { type: Object, required: !1 }
  },
  setup(e, { slots: t }) {
    const a = i(s(e, "appear")), l = i(s(e, "noFade")), n = G(e.transProps);
    return Jt(n.value) || (n.value = l.value ? _a : Li, a.value && (n.value = {
      ...n.value,
      appear: !0,
      appearClass: n.value.enterClass,
      appearActiveClass: n.value.enterActiveClass,
      appearToClass: n.value.enterToClass
    })), n.value = {
      mode: e.mode,
      ...n.value,
      css: !0
    }, () => W(
      tl,
      { ...n.value },
      {
        default: () => t.default ? t.default() : []
      }
    );
  }
}), nt = { top: 0, left: 0, bottom: 0, right: 0 }, Pi = "default", Ei = "overlay", Hi = C({
  components: { BTransition: Ue },
  props: {
    bgColor: { type: String, required: !1 },
    blur: { type: String, default: "2px" },
    fixed: { type: [Boolean, String], default: !1 },
    noCenter: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noWrap: { type: [Boolean, String], default: !1 },
    opacity: {
      type: [Number, String],
      default: 0.85,
      validator: (e) => {
        const t = gt(e, 0);
        return t >= 0 && t <= 1;
      }
    },
    overlayTag: { type: String, default: "div" },
    rounded: { type: [Boolean, String], default: !1 },
    show: { type: [Boolean, String], default: !1 },
    spinnerSmall: { type: [Boolean, String], default: !1 },
    spinnerType: { type: String, default: "border" },
    spinnerVariant: { type: String, required: !1 },
    variant: { type: String, default: "light" },
    wrapTag: { type: String, default: "div" },
    zIndex: { type: [Number, String], default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { slots: t, emit: a }) {
    const l = i(s(e, "fixed")), n = i(s(e, "noCenter")), r = i(s(e, "noFade")), d = i(s(e, "noWrap")), v = i(s(e, "show")), g = i(s(e, "spinnerSmall")), B = u(
      () => e.rounded === !0 || e.rounded === "" ? "rounded" : e.rounded ? `rounded-${e.rounded}` : ""
    ), y = u(
      () => e.variant && !e.bgColor ? `bg-${e.variant}` : ""
    ), h = u(() => ({
      spinnerType: e.spinnerType || null,
      spinnerVariant: e.spinnerVariant || null,
      spinnerSmall: g.value
    }));
    return () => {
      const T = (f) => W(We("BSpinner"), {
        type: f.spinnerType,
        variant: f.spinnerVariant,
        small: g.value
      });
      let V = "";
      if (v.value) {
        const f = W("div", {
          class: ["position-absolute", y.value, B.value],
          style: {
            ...nt,
            opacity: e.opacity,
            backgroundColor: e.bgColor || null,
            backdropFilter: e.blur ? `blur(${e.blur})` : null
          }
        }), m = W(
          "div",
          {
            class: "position-absolute",
            style: n.value ? { ...nt } : { top: "50%", left: "50%", transform: "translateX(-50%) translateY(-50%)" }
          },
          ve(Ei, h.value, t) || T(h.value) || ""
        );
        V = W(
          e.overlayTag,
          {
            class: [
              "b-overlay",
              {
                "position-absolute": !d.value || d.value && !l.value,
                "position-fixed": d.value && l.value
              }
            ],
            style: {
              ...nt,
              zIndex: e.zIndex || 10
            },
            onClick: (I) => a("click", I),
            key: "overlay"
          },
          [f, m]
        );
      }
      const k = () => W(
        Ue,
        {
          noFade: r.value,
          transProps: { enterToClass: "show" },
          name: "fade",
          onAfterEnter: () => a("shown"),
          onAfterLeave: () => a("hidden")
        },
        { default: () => V }
      );
      return d.value ? k() : W(
        e.wrapTag,
        {
          class: ["b-overlay-wrap position-relative"],
          "aria-busy": v.value ? "true" : null
        },
        [W("span", ve(Pi, {}, t)), k()]
      );
    };
  }
}), qi = 5, Aa = 20, xa = 0, me = 3, Ri = "ellipsis-text", ji = "first-text", Di = "last-text", Mi = "next-text", Gi = "page", Ui = "prev-text", Ot = (e) => Math.max(xe(e) || Aa, 1), Nt = (e) => Math.max(xe(e) || xa, 0), Wi = (e, t) => {
  const a = xe(e) || 1;
  return a > t ? t : a < 1 ? 1 : a;
}, Xi = C({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, required: !1 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "\u2026" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { type: String, default: "\xAB" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { type: String, default: "\xBB" },
    limit: { type: Number, default: qi },
    modelValue: { type: Number, default: 1 },
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "\u203A" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: Aa },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "\u2039" },
    size: { type: String, required: !1 },
    totalRows: { type: Number, default: xa }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: a }) {
    const l = i(s(e, "disabled")), n = i(s(e, "firstNumber")), r = i(s(e, "hideEllipsis")), d = i(s(e, "hideGotoEndButtons")), v = i(s(e, "lastNumber")), g = i(s(e, "pills")), B = ul(s(e, "align")), y = u(
      () => Math.ceil(Nt(e.totalRows) / Ot(e.perPage))
    ), h = u(() => {
      let S;
      return y.value - e.modelValue + 2 < e.limit && e.limit > me ? S = y.value - V.value + 1 : S = e.modelValue - Math.floor(V.value / 2), S < 1 ? S = 1 : S > y.value - V.value && (S = y.value - V.value + 1), e.limit <= me && v.value && y.value === S + V.value - 1 && (S = Math.max(S - 1, 1)), S;
    }), T = u(() => {
      const S = y.value - e.modelValue;
      let _ = !1;
      return S + 2 < e.limit && e.limit > me ? e.limit > me && (_ = !0) : e.limit > me && (_ = !!(!r.value || n.value)), h.value <= 1 && (_ = !1), _ && n.value && h.value < 4 && (_ = !1), _;
    }), V = u(() => {
      let S = e.limit;
      return y.value <= e.limit ? S = y.value : e.modelValue < e.limit - 1 && e.limit > me ? ((!r.value || v.value) && (S = e.limit - (n.value ? 0 : 1)), S = Math.min(S, e.limit)) : y.value - e.modelValue + 2 < e.limit && e.limit > me ? (!r.value || n.value) && (S = e.limit - (v.value ? 0 : 1)) : e.limit > me && (S = e.limit - (r.value ? 0 : 2)), S;
    }), k = u(() => {
      const S = y.value - V.value;
      let _ = !1;
      e.modelValue < e.limit - 1 && e.limit > me ? (!r.value || v.value) && (_ = !0) : e.limit > me && (_ = !!(!r.value || v.value)), h.value > S && (_ = !1);
      const F = h.value + V.value - 1;
      return _ && v.value && F > y.value - 3 && (_ = !1), _;
    }), p = ye({
      pageSize: Ot(e.perPage),
      totalRows: Nt(e.totalRows),
      numberOfPages: y.value
    }), f = (S, _) => {
      if (_ === e.modelValue)
        return;
      const { target: F } = S, j = new Xe("page-click", {
        cancelable: !0,
        vueTarget: this,
        target: F
      });
      t("page-click", j, _), !j.defaultPrevented && t("update:modelValue", _);
    }, m = u(() => e.size ? `pagination-${e.size}` : ""), I = u(() => g.value ? "b-pagination-pills" : "");
    ie(
      () => e.modelValue,
      (S) => {
        const _ = Wi(S, y.value);
        _ !== e.modelValue && t("update:modelValue", _);
      }
    ), ie(p, (S, _) => {
      Ut(S) || (_.pageSize !== S.pageSize && _.totalRows === S.totalRows || _.numberOfPages !== S.numberOfPages && e.modelValue > _.numberOfPages) && t("update:modelValue", 1);
    });
    const z = u(() => {
      const S = [];
      for (let _ = 0; _ < V.value; _++)
        S.push({ number: h.value + _, classes: null });
      return S;
    });
    return () => {
      const S = [], _ = z.value.map((R) => R.number), F = (R) => R === e.modelValue, j = e.modelValue < 1, A = e.align === "fill", w = (R, se, re, J, M, ue) => {
        const ne = l.value || F(ue) || j || R < 1 || R > y.value, pe = R < 1 ? 1 : R > y.value ? y.value : R, Ze = { disabled: ne, page: pe, index: pe - 1 }, U = ve(re, Ze, a) || J || "";
        return W(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: ne,
                "flex-fill": A,
                "d-flex": A && !ne
              },
              M
            ]
          },
          W(
            ne ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !ne && A }],
              "aria-label": se,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": ne ? "true" : null,
              role: "menuitem",
              type: ne ? null : "button",
              tabindex: ne ? null : "-1",
              onClick: (ee) => {
                ne || f(ee, pe);
              }
            },
            U
          )
        );
      }, O = (R) => W(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            A ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${R ? "last" : "first"}`
        },
        [
          W(
            "span",
            { class: ["page-link"] },
            ve(Ri, {}, a) || e.ellipsisText || "..."
          )
        ]
      ), K = (R, se) => {
        const re = F(R.number) && !j, J = l.value ? null : re || j && se === 0 ? "0" : "-1", M = {
          active: re,
          disabled: l.value,
          page: R.number,
          index: R.number - 1,
          content: R.number
        }, ue = ve(Gi, M, a) || R.number, ne = W(
          l.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !l.value && A }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": l.value ? "true" : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${R.number}` : null,
            role: "menuitemradio",
            type: l.value ? null : "button",
            tabindex: J,
            onClick: (pe) => {
              l.value || f(pe, R.number);
            }
          },
          ue
        );
        return W(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: l.value,
                active: re,
                "flex-fill": A,
                "d-flex": A && !l.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${R.number}`
          },
          ne
        );
      };
      if (!d.value && !n.value) {
        const R = w(
          1,
          e.labelFirstPage,
          ji,
          e.firstText,
          e.firstClass,
          1
        );
        S.push(R);
      }
      const Z = w(
        e.modelValue - 1,
        e.labelFirstPage,
        Ui,
        e.prevText,
        e.prevClass,
        1
      );
      S.push(Z), n.value && _[0] !== 1 && S.push(K({ number: 1 }, 0)), T.value && S.push(O(!1)), z.value.forEach((R, se) => {
        const re = T.value && n.value && _[0] !== 1 ? 1 : 0;
        S.push(K(R, se + re));
      }), k.value && S.push(O(!0)), v.value && _[_.length - 1] !== y.value && S.push(K({ number: y.value }, -1));
      const Y = w(
        e.modelValue + 1,
        e.labelNextPage,
        Mi,
        e.nextText,
        e.nextClass,
        y.value
      );
      if (S.push(Y), !v.value && !d.value) {
        const R = w(
          y.value,
          e.labelLastPage,
          Di,
          e.lastText,
          e.lastClass,
          y.value
        );
        S.push(R);
      }
      return W(
        "ul",
        {
          class: ["pagination", m.value, B.value, I.value],
          role: "menubar",
          "aria-disabled": l.value,
          "aria-label": e.ariaLabel || null
        },
        S
      );
    };
  }
}), Ki = C({
  props: {
    container: {
      type: [String, Object],
      default: "body"
    },
    content: { type: String },
    id: { type: String },
    customClass: { type: String, default: "" },
    noninteractive: { type: [Boolean, String], default: !1 },
    placement: { type: String, default: "right" },
    target: {
      type: [String, Object],
      default: void 0
    },
    title: { type: String },
    delay: { type: [Number, Object], default: 0 },
    triggers: { type: String, default: "click" },
    show: { type: [Boolean, String], default: !1 },
    variant: { type: String, default: void 0 },
    html: { type: [Boolean, String], default: !0 },
    sanitize: { type: [Boolean, String], default: !1 },
    offset: { type: String, default: "0" }
  },
  emits: ["show", "shown", "hide", "hidden", "inserted"],
  setup(e, { emit: t, slots: a }) {
    i(s(e, "noninteractive"));
    const l = i(s(e, "show")), n = i(s(e, "html")), r = i(s(e, "sanitize")), d = G(), v = G(), g = G(), B = G(), y = G(), h = u(() => ({
      [`b-popover-${e.variant}`]: e.variant !== void 0
    })), T = (p) => {
      if (typeof p == "string")
        return p;
      if (p instanceof HTMLElement)
        return p;
      if (typeof p < "u")
        return p.$el;
    }, V = (p) => {
      if (!!p) {
        if (typeof p == "string") {
          const f = document.getElementById(p);
          return f || void 0;
        }
        return p;
      }
    }, k = (p) => {
      v.value = V(T(p)), v.value && (g.value = new st(v.value, {
        customClass: e.customClass,
        container: T(e.container),
        trigger: e.triggers,
        placement: e.placement,
        title: e.title || a.title ? B.value : "",
        content: y.value,
        html: n.value,
        delay: e.delay,
        sanitize: r.value,
        offset: e.offset
      }));
    };
    return de(() => {
      var p, f, m;
      Se(() => {
        k(e.target);
      }), (f = (p = d.value) == null ? void 0 : p.parentNode) == null || f.removeChild(d.value), l.value && ((m = g.value) == null || m.show());
    }), bt(() => {
      var p;
      (p = g.value) == null || p.dispose();
    }), ie(
      () => e.target,
      (p) => {
        var f;
        (f = g.value) == null || f.dispose(), k(p);
      }
    ), ie(
      () => l.value,
      (p, f) => {
        var m, I;
        p !== f && (p ? (m = g.value) == null || m.show() : (I = g.value) == null || I.hide());
      }
    ), ae(v, "show.bs.popover", () => t("show")), ae(v, "shown.bs.popover", () => t("shown")), ae(v, "hide.bs.popover", () => t("hide")), ae(v, "hidden.bs.popover", () => t("hidden")), ae(v, "inserted.bs.popover", () => t("inserted")), {
      element: d,
      titleRef: B,
      contentRef: y,
      classes: h
    };
  }
}), Ji = ["id"], Yi = { ref: "titleRef" }, Zi = { ref: "contentRef" };
function Qi(e, t, a, l, n, r) {
  return c(), b("div", {
    id: e.id,
    ref: "element",
    class: x(["popover b-popover", e.classes]),
    role: "tooltip",
    tabindex: "-1"
  }, [
    E("div", Yi, [
      $(e.$slots, "title", {}, () => [
        Q(H(e.title), 1)
      ])
    ], 512),
    E("div", Zi, [
      $(e.$slots, "default", {}, () => [
        Q(H(e.content), 1)
      ])
    ], 512)
  ], 10, Ji);
}
const er = /* @__PURE__ */ fe(Ki, [["render", Qi]]), Fa = C({
  props: {
    animated: { type: [Boolean, String], default: !1 },
    label: { type: String },
    labelHtml: { type: String },
    max: { type: [Number, String] },
    precision: { type: [Number, String], default: 0 },
    showProgress: { type: [Boolean, String], default: !1 },
    showValue: { type: [Boolean, String], default: !1 },
    striped: { type: [Boolean, String], default: !1 },
    value: { type: [Number, String], default: 0 },
    variant: { type: String }
  },
  setup(e, { slots: t }) {
    const a = i(s(e, "animated")), l = i(s(e, "showProgress")), n = i(s(e, "showValue")), r = i(s(e, "striped")), d = Be(Ia), v = u(() => ({
      "progress-bar-animated": a.value || (d == null ? void 0 : d.animated),
      "progress-bar-striped": r.value || (d == null ? void 0 : d.striped) || a.value || (d == null ? void 0 : d.animated),
      [`bg-${e.variant}`]: e.variant
    })), g = u(() => {
      if (n.value || (d == null ? void 0 : d.showValue))
        return parseFloat(e.value).toFixed(e.precision);
      if (l.value || (d == null ? void 0 : d.showProgress)) {
        const h = (e.value * 100 / parseInt(e.max || 100)).toString();
        return parseFloat(h).toFixed(e.precision);
      }
      return e.label || "";
    }), B = u(() => e.max || (d == null ? void 0 : d.max) ? `${e.value * 100 / parseInt(e.max || (d == null ? void 0 : d.max))}%` : typeof e.value == "string" ? e.value : `${e.value}%`), y = u(() => {
      const h = {
        class: ["progress-bar", v.value],
        role: "progressbar",
        "aria-valuenow": e.value,
        "aria-valuemin": 0,
        "aria-valuemax": e.max,
        style: { width: B.value }
      };
      return e.labelHtml ? {
        ...h,
        innerHTML: e.labelHtml
      } : h;
    });
    return () => {
      var h;
      return W("div", y.value, ((h = t.default) == null ? void 0 : h.call(t)) || g.value);
    };
  }
}), Ia = Symbol(), tr = /* @__PURE__ */ C({
  __name: "BProgress",
  props: {
    variant: null,
    max: null,
    height: null,
    animated: { default: !1 },
    precision: { default: 0 },
    showProgress: { default: !1 },
    showValue: { default: !1 },
    striped: { default: !1 },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, a = i(s(t, "animated")), l = i(s(t, "showProgress")), n = i(s(t, "showValue")), r = i(s(t, "striped"));
    return Fe(Ia, {
      animated: a.value,
      max: t.max,
      showProgress: l.value,
      showValue: n.value,
      striped: r.value
    }), (d, v) => (c(), b("div", {
      class: "progress",
      style: _e({ height: e.height })
    }, [
      $(d.$slots, "default", {}, () => [
        ge(Fa, Oe(Ne({
          animated: o(a),
          max: e.max,
          precision: e.precision,
          showProgress: o(l),
          showValue: o(n),
          striped: o(r),
          value: e.value,
          variant: e.variant
        })), null, 16)
      ])
    ], 4));
  }
}), zt = Ke("cols", [""], { type: [String, Number], default: null }), ar = C({
  name: "BRow",
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...zt
  },
  setup(e) {
    const t = Gt(e, zt, "cols", "row-cols");
    return {
      classes: u(() => ({
        [`gx-${e.gutterX}`]: e.gutterX !== null,
        [`gy-${e.gutterY}`]: e.gutterY !== null,
        [`align-items-${e.alignV}`]: e.alignV !== null,
        [`justify-content-${e.alignH}`]: e.alignH !== null,
        [`align-content-${e.alignContent}`]: e.alignContent !== null
      })),
      rowColsClasses: t
    };
  }
});
function lr(e, t, a, l, n, r) {
  return c(), N(q(e.tag), {
    class: x(["row", [e.classes, e.rowColsClasses]])
  }, {
    default: L(() => [
      $(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const nr = /* @__PURE__ */ fe(ar, [["render", lr]]), Me = /* @__PURE__ */ C({
  __name: "BSkeleton",
  props: {
    height: null,
    width: null,
    size: null,
    animation: { default: "wave" },
    type: { default: "text" },
    variant: null
  },
  setup(e) {
    const t = e, a = u(() => [
      `b-skeleton-${t.type}`,
      {
        [`b-skeleton-animate-${t.animation}`]: typeof t.animation == "boolean" ? void 0 : t.animation,
        [`bg-${t.variant}`]: t.variant
      }
    ]), l = u(() => ({
      width: t.size || t.width,
      height: t.size || t.height
    }));
    return (n, r) => (c(), b("div", {
      class: x(["b-skeleton", o(a)]),
      style: _e(o(l))
    }, null, 6));
  }
}), sr = /* @__PURE__ */ C({
  __name: "BSkeletonIcon",
  props: {
    animation: { default: "wave" }
  },
  setup(e) {
    const t = e, a = u(() => [`b-skeleton-animate-${t.animation}`]);
    return (l, n) => (c(), b("div", {
      class: x(["b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden", o(a)])
    }, [
      $(l.$slots, "default")
    ], 2));
  }
}), Oa = /* @__PURE__ */ C({
  __name: "BTableSimple",
  props: {
    bordered: { default: !1 },
    borderless: { default: !1 },
    borderVariant: null,
    captionTop: { default: !1 },
    dark: { default: !1 },
    hover: { default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { default: !1 },
    small: { default: !1 },
    tableClass: null,
    tableVariant: null
  },
  setup(e) {
    const t = e, a = i(s(t, "captionTop")), l = i(s(t, "borderless")), n = i(s(t, "bordered")), r = i(s(t, "dark")), d = i(s(t, "hover")), v = i(s(t, "small")), g = i(s(t, "striped")), B = u(() => [
      "table",
      "b-table",
      {
        "table-bordered": n.value,
        "table-borderless": l.value,
        [`border-${t.borderVariant}`]: t.borderVariant,
        "caption-top": a.value,
        "table-dark": r.value,
        "table-hover": d.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": g.value,
        "table-sm": v.value,
        [`table-${t.tableVariant}`]: t.tableVariant
      },
      t.tableClass
    ]), y = u(() => [
      {
        "table-responsive": typeof t.responsive == "boolean" && t.responsive,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string"
      }
    ]);
    return (h, T) => e.responsive ? (c(), b("div", {
      key: 0,
      class: x(o(y))
    }, [
      E("table", {
        role: "table",
        class: x(o(B))
      }, [
        $(h.$slots, "default")
      ], 2)
    ], 2)) : (c(), b("table", {
      key: 1,
      role: "table",
      class: x(o(B))
    }, [
      $(h.$slots, "default")
    ], 2));
  }
}), or = { key: 0 }, ir = { key: 1 }, rr = /* @__PURE__ */ C({
  __name: "BSkeletonTable",
  props: {
    animation: { default: "wave" },
    columns: { default: 5 },
    hideHeader: { default: !1 },
    rows: { default: 3 },
    showFooter: { default: !1 },
    tableProps: null
  },
  setup(e) {
    const t = e, a = i(s(t, "hideHeader")), l = i(s(t, "showFooter"));
    return (n, r) => (c(), N(Oa, Oe(Ne(e.tableProps)), {
      default: L(() => [
        o(a) ? P("", !0) : (c(), b("thead", or, [
          E("tr", null, [
            (c(!0), b(X, null, te(e.columns, (d, v) => (c(), b("th", { key: v }, [
              ge(Me)
            ]))), 128))
          ])
        ])),
        E("tbody", null, [
          (c(!0), b(X, null, te(e.rows, (d, v) => (c(), b("tr", { key: v }, [
            (c(!0), b(X, null, te(e.columns, (g, B) => (c(), b("td", { key: B }, [
              ge(Me, { width: "75%" })
            ]))), 128))
          ]))), 128))
        ]),
        o(l) ? (c(), b("tfoot", ir, [
          E("tr", null, [
            (c(!0), b(X, null, te(e.columns, (d, v) => (c(), b("th", { key: v }, [
              ge(Me)
            ]))), 128))
          ])
        ])) : P("", !0)
      ]),
      _: 1
    }, 16));
  }
}), ur = /* @__PURE__ */ C({
  __name: "BSkeletonWrapper",
  props: {
    loading: { default: !1 }
  },
  setup(e) {
    const a = i(s(e, "loading"));
    return (l, n) => o(a) ? $(l.$slots, "loading", { key: 0 }) : $(l.$slots, "default", { key: 1 });
  }
}), dr = {
  key: 0,
  class: "visually-hidden"
}, cr = /* @__PURE__ */ C({
  __name: "BSpinner",
  props: {
    label: null,
    role: { default: "status" },
    small: { default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: null
  },
  setup(e) {
    const t = e, a = i(s(t, "small")), l = u(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && a.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && a.value,
      [`text-${t.variant}`]: t.variant !== void 0
    }));
    return (n, r) => (c(), N(q(e.tag), {
      class: x(o(l)),
      role: e.label || n.$slots.label ? e.role : null,
      "aria-hidden": e.label || n.$slots.label ? null : !0
    }, {
      default: L(() => [
        e.label || n.$slots.label ? (c(), b("span", dr, [
          $(n.$slots, "label", {}, () => [
            Q(H(e.label), 1)
          ])
        ])) : P("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), fr = () => ({
  normaliseFields: (t, a) => {
    const l = [];
    return !(t != null && t.length) && (a == null ? void 0 : a.length) ? (Object.keys(a[0]).forEach((n) => l.push({ key: n, label: Tt(n) })), l) : (Array.isArray(t) && t.forEach((n) => {
      typeof n == "string" ? l.push({ key: n, label: Tt(n) }) : xl(n) && n.key && Ae(n.key) && l.push({ ...n });
    }), l);
  }
}), vr = ["title", "abbr"], br = { key: 1 }, mr = { key: 0 }, gr = ["title", "abbr"], pr = { key: 1 }, hr = { key: 2 }, yr = ["title", "abbr"], Br = { key: 1 }, $r = { key: 0 }, kr = ["title", "abbr"], Sr = { key: 1 }, Tr = { key: 2 }, Cr = /* @__PURE__ */ C({
  __name: "BTable",
  props: {
    align: null,
    caption: null,
    captionTop: { default: !1 },
    borderless: { default: !1 },
    bordered: { default: !1 },
    borderVariant: null,
    dark: { default: !1 },
    fields: { default: () => [] },
    footClone: { default: !1 },
    hover: { default: !1 },
    items: { default: () => [] },
    responsive: { type: [Boolean, String], default: !1 },
    small: { default: !1 },
    striped: { default: !1 },
    variant: null
  },
  setup(e) {
    const t = e, a = i(s(t, "captionTop")), l = i(s(t, "borderless")), n = i(s(t, "bordered")), r = i(s(t, "dark")), d = i(s(t, "footClone")), v = i(s(t, "hover")), g = i(s(t, "small")), B = i(s(t, "striped")), y = u(() => [
      "table",
      {
        [`align-${t.align}`]: t.align,
        [`table-${t.variant}`]: t.variant,
        "table-striped": B.value,
        "table-hover": v.value,
        "table-dark": r.value,
        "table-bordered": n.value,
        [`border-${t.borderVariant}`]: t.borderVariant,
        "table-borderless": l.value,
        "table-sm": g.value,
        "caption-top": a.value
      }
    ]), h = fr(), T = u(() => h.normaliseFields(t.fields, t.items)), V = u(() => [
      {
        "table-responsive": typeof t.responsive == "boolean" && t.responsive,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string"
      }
    ]);
    return (k, p) => e.responsive ? (c(), b("div", {
      key: 0,
      class: x(o(V))
    }, [
      E("table", {
        class: x(o(y))
      }, [
        E("thead", null, [
          k.$slots["thead-top"] ? $(k.$slots, "thead-top", { key: 0 }) : P("", !0),
          E("tr", null, [
            (c(!0), b(X, null, te(o(T), (f) => (c(), b("th", D({
              key: f.key,
              scope: "col",
              class: [f.class, f.thClass, f.variant ? `table-${f.variant}` : ""],
              title: f.headerTitle,
              abbr: f.headerAbbr,
              style: f.thStyle
            }, f.thAttr), [
              k.$slots["head(" + f.key + ")"] ? $(k.$slots, "head(" + f.key + ")", {
                key: 0,
                label: f.label
              }) : (c(), b(X, { key: 1 }, [
                Q(H(f.label), 1)
              ], 64))
            ], 16, vr))), 128))
          ]),
          k.$slots["thead-sub"] ? (c(), b("tr", br, [
            (c(!0), b(X, null, te(o(T), (f) => (c(), b("td", {
              key: f.key,
              scope: "col",
              class: x([f.class, f.thClass, f.variant ? `table-${f.variant}` : ""])
            }, [
              k.$slots["thead-sub"] ? $(k.$slots, "thead-sub", D({
                key: 0,
                items: o(T)
              }, f)) : (c(), b(X, { key: 1 }, [
                Q(H(f.label), 1)
              ], 64))
            ], 2))), 128))
          ])) : P("", !0)
        ]),
        E("tbody", null, [
          (c(!0), b(X, null, te(e.items, (f) => (c(), b("tr", {
            class: x([f._rowVariant ? `table-${f._rowVariant}` : null])
          }, [
            (c(!0), b(X, null, te(o(T), (m, I) => (c(), b("td", D({
              key: m.key
            }, m.tdAttr, {
              class: [
                m.class,
                m.tdClass,
                m.variant ? `table-${m.variant}` : "",
                (f == null ? void 0 : f._cellVariants) && (f == null ? void 0 : f._cellVariants[m.key]) ? `table-${f == null ? void 0 : f._cellVariants[m.key]}` : ""
              ]
            }), [
              k.$slots["cell(" + m.key + ")"] ? $(k.$slots, "cell(" + m.key + ")", {
                key: 0,
                value: f[m.key],
                index: I,
                item: f,
                items: e.items
              }) : (c(), b(X, { key: 1 }, [
                Q(H(f[m.key]), 1)
              ], 64))
            ], 16))), 128))
          ], 2))), 256))
        ]),
        o(d) ? (c(), b("tfoot", mr, [
          E("tr", null, [
            (c(!0), b(X, null, te(o(T), (f) => (c(), b("th", D({
              key: f.key
            }, f.thAttr, {
              scope: "col",
              class: [f.class, f.thClass, f.variant ? `table-${f.variant}` : ""],
              title: f.headerTitle,
              abbr: f.headerAbbr,
              style: f.thStyle
            }), H(f.label), 17, gr))), 128))
          ])
        ])) : P("", !0),
        k.$slots["table-caption"] ? (c(), b("caption", pr, [
          $(k.$slots, "table-caption")
        ])) : e.caption ? (c(), b("caption", hr, H(e.caption), 1)) : P("", !0)
      ], 2)
    ], 2)) : (c(), b("table", {
      key: 1,
      class: x(o(y))
    }, [
      E("thead", null, [
        k.$slots["thead-top"] ? $(k.$slots, "thead-top", { key: 0 }) : P("", !0),
        E("tr", null, [
          (c(!0), b(X, null, te(o(T), (f) => (c(), b("th", D({
            key: f.key,
            scope: "col",
            class: [f.class, f.thClass, f.variant ? `table-${f.variant}` : ""],
            title: f.headerTitle,
            abbr: f.headerAbbr,
            style: f.thStyle
          }, f.thAttr), [
            k.$slots["head(" + f.key + ")"] ? $(k.$slots, "head(" + f.key + ")", {
              key: 0,
              label: f.label
            }) : (c(), b(X, { key: 1 }, [
              Q(H(f.label), 1)
            ], 64))
          ], 16, yr))), 128))
        ]),
        k.$slots["thead-sub"] ? (c(), b("tr", Br, [
          (c(!0), b(X, null, te(o(T), (f) => (c(), b("td", {
            key: f.key,
            scope: "col",
            class: x([f.class, f.thClass, f.variant ? `table-${f.variant}` : ""])
          }, [
            k.$slots["thead-sub"] ? $(k.$slots, "thead-sub", D({
              key: 0,
              items: o(T)
            }, f)) : (c(), b(X, { key: 1 }, [
              Q(H(f.label), 1)
            ], 64))
          ], 2))), 128))
        ])) : P("", !0)
      ]),
      E("tbody", null, [
        (c(!0), b(X, null, te(e.items, (f) => (c(), b("tr", {
          class: x([f._rowVariant ? `table-${f._rowVariant}` : null])
        }, [
          (c(!0), b(X, null, te(o(T), (m, I) => (c(), b("td", D({
            key: m.key
          }, m.tdAttr, {
            class: [
              m.class,
              m.tdClass,
              m.variant ? `table-${m.variant}` : "",
              (f == null ? void 0 : f._cellVariants) && (f == null ? void 0 : f._cellVariants[m.key]) ? `table-${f == null ? void 0 : f._cellVariants[m.key]}` : ""
            ]
          }), [
            k.$slots["cell(" + m.key + ")"] ? $(k.$slots, "cell(" + m.key + ")", {
              key: 0,
              value: f[m.key],
              index: I,
              item: f,
              items: e.items
            }) : (c(), b(X, { key: 1 }, [
              Q(H(f[m.key]), 1)
            ], 64))
          ], 16))), 128))
        ], 2))), 256))
      ]),
      o(d) ? (c(), b("tfoot", $r, [
        E("tr", null, [
          (c(!0), b(X, null, te(o(T), (f) => (c(), b("th", D({
            key: f.key
          }, f.thAttr, {
            scope: "col",
            class: [f.class, f.thClass, f.variant ? `table-${f.variant}` : ""],
            title: f.headerTitle,
            abbr: f.headerAbbr,
            style: f.thStyle
          }), H(f.label), 17, kr))), 128))
        ])
      ])) : P("", !0),
      k.$slots["table-caption"] ? (c(), b("caption", Sr, [
        $(k.$slots, "table-caption")
      ])) : e.caption ? (c(), b("caption", Tr, H(e.caption), 1)) : P("", !0)
    ], 2));
  }
}), Vr = /* @__PURE__ */ C({
  __name: "BTbody",
  props: {
    headVariant: { default: !1 }
  },
  setup(e) {
    const t = e, a = i(s(t, "headVariant")), l = u(() => ({
      [`thead-${t.headVariant}`]: a.value
    }));
    return (n, r) => (c(), b("tbody", {
      role: "rowgroup",
      class: x(o(l))
    }, [
      $(n.$slots, "default")
    ], 2));
  }
}), wr = ["scope", "colspan", "rowspan", "data-label"], _r = { key: 0 }, Ar = /* @__PURE__ */ C({
  __name: "BTd",
  props: {
    colspan: null,
    rowspan: null,
    stackedHeading: null,
    stickyColumn: { default: !1 },
    variant: null
  },
  setup(e) {
    const t = e, a = i(s(t, "stickyColumn")), l = u(() => ({
      [`table-${t.variant}`]: t.variant,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && !t.variant
    })), n = u(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (r, d) => (c(), b("td", {
      role: "cell",
      scope: o(n),
      class: x(o(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading ? (c(), b("div", _r, [
        $(r.$slots, "default")
      ])) : $(r.$slots, "default", { key: 1 })
    ], 10, wr));
  }
}), xr = /* @__PURE__ */ C({
  __name: "BTfoot",
  props: {
    footVariant: null
  },
  setup(e) {
    const t = e, a = t.footVariant !== void 0 ? i(s(t, "footVariant")) : u(() => {
    }), l = u(() => ({
      [`table-${t.footVariant}`]: a.value
    }));
    return (n, r) => (c(), b("tfoot", {
      role: "rowgroup",
      class: x(o(l))
    }, [
      $(n.$slots, "default")
    ], 2));
  }
}), Fr = ["scope", "colspan", "rowspan", "data-label"], Ir = { key: 0 }, Or = /* @__PURE__ */ C({
  __name: "BTh",
  props: {
    colspan: null,
    rowspan: null,
    stackedHeading: null,
    stickyColumn: { default: !1 },
    variant: null
  },
  setup(e) {
    const t = e, a = i(s(t, "stickyColumn")), l = u(() => ({
      [`table-${t.variant}`]: t.variant,
      "b-table-sticky-column": a.value,
      "table-b-table-default": a.value && !t.variant
    })), n = u(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (r, d) => (c(), b("th", {
      role: "columnheader",
      scope: o(n),
      class: x(o(l)),
      colspan: e.colspan,
      rowspan: e.rowspan,
      "data-label": e.stackedHeading
    }, [
      e.stackedHeading ? (c(), b("div", Ir, [
        $(r.$slots, "default")
      ])) : $(r.$slots, "default", { key: 1 })
    ], 10, Fr));
  }
}), Nr = /* @__PURE__ */ C({
  __name: "BThead",
  props: {
    headVariant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`table-${t.headVariant}`]: t.headVariant
    }));
    return (l, n) => (c(), b("thead", {
      role: "rowgroup",
      class: x(o(a))
    }, [
      $(l.$slots, "default")
    ], 2));
  }
}), zr = /* @__PURE__ */ C({
  __name: "BTr",
  props: {
    variant: null
  },
  setup(e) {
    const t = e, a = u(() => ({
      [`table-${t.variant}`]: t.variant
    }));
    return (l, n) => (c(), b("tr", {
      role: "row",
      class: x(o(a))
    }, [
      $(l.$slots, "default")
    ], 2));
  }
}), Lr = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"], Na = Symbol(), Pr = /* @__PURE__ */ C({
  __name: "BTabs",
  props: {
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    card: { default: !1 },
    contentClass: { default: void 0 },
    end: { default: !1 },
    fill: { default: !1 },
    id: { default: void 0 },
    justified: { default: !1 },
    lazy: { default: !1 },
    navClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { default: !1 },
    noNavStyle: { default: !1 },
    pills: { default: !1 },
    small: { default: !1 },
    tag: { default: "div" },
    vertical: { default: !1 },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const a = e, l = i(s(a, "card")), n = i(s(a, "end")), r = i(s(a, "fill")), d = i(s(a, "justified")), v = i(s(a, "lazy")), g = i(s(a, "noFade")), B = i(s(a, "noNavStyle")), y = i(s(a, "pills")), h = i(s(a, "small")), T = i(s(a, "vertical")), V = Te(), k = G(a.modelValue), p = G(""), f = u({
      get: () => k.value,
      set: (A) => {
        k.value = A, m.value.length > 0 && A >= 0 && A < m.value.length ? p.value = m.value[A].buttonId : p.value = "", t("update:modelValue", A);
      }
    }), m = u(() => {
      let A = [];
      return V.default && (A = j(V).map((w, O) => {
        w.props || (w.props = {});
        const K = w.props["button-id"] || he("tab"), Z = w.props.id || he(), Y = f.value > -1 ? O === f.value : w.props.active === "", R = w.props["title-item-class"], se = w.props["title-link-attributes"];
        return {
          buttonId: K,
          contentId: Z,
          active: Y,
          disabled: w.props.disabled === "" || w.props.disabled === !0,
          navItemClasses: [
            {
              active: Y,
              disabled: w.props.disabled === "" || w.props.disabled === !0
            },
            Y && a.activeNavItemClass ? a.activeNavItemClass : null,
            w.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !g.value
            },
            Y && a.activeTabClass ? a.activeTabClass : null
          ],
          target: `#${Z}`,
          title: w.props.title,
          titleItemClass: R,
          titleLinkAttributes: se,
          onClick: w.props.onClick,
          tab: w
        };
      })), A;
    }), I = u(() => !((m == null ? void 0 : m.value) && m.value.length > 0)), z = u(() => ({
      "d-flex align-items-start": T.value
    })), S = u(() => ({
      "nav-pills": y.value,
      "flex-column me-3": T.value,
      [`justify-content-${a.align}`]: !!a.align,
      "nav-fill": r.value,
      "card-header-tabs": l.value,
      "nav-justified": d.value,
      "nav-tabs": !B.value && !y.value,
      small: h.value
    })), _ = (A) => {
      let w = !1;
      if (A !== void 0 && A > -1 && A < m.value.length && !m.value[A].disabled && (f.value < 0 || m.value[A].buttonId !== p.value)) {
        const O = new Xe("activate-tab", { cancelable: !0, vueTarget: this });
        t("activate-tab", A, f.value, O), O.defaultPrevented || (f.value = A, w = !0);
      }
      return !w && a.modelValue !== f.value && t("update:modelValue", f.value), w;
    }, F = (A, w) => {
      var O;
      _(w), w >= 0 && !m.value[w].disabled && ((O = m.value[w]) == null ? void 0 : O.onClick) && Kt(m.value[w].onClick) && m.value[w].onClick(A);
    }, j = (A) => !A || !A.default ? [] : A.default().reduce((w, O) => (typeof O.type == "symbol" ? w = w.concat(O.children) : w.push(O), w), []).filter((w) => {
      var O;
      return ((O = w.type) == null ? void 0 : O.__name) === "BTab";
    });
    return _(k.value), ie(
      () => a.modelValue,
      (A, w) => {
        if (A === w)
          return;
        if (A = Math.max(A, -1), w = Math.max(w, -1), m.value.length <= 0) {
          f.value = -1;
          return;
        }
        const O = A > w;
        let K = A;
        const Z = m.value.length - 1;
        for (; K >= 0 && K <= Z && m.value[K].disabled; )
          K += O ? 1 : -1;
        if (K < 0) {
          _(0);
          return;
        }
        if (K >= m.value.length) {
          _(m.value.length - 1);
          return;
        }
        _(K);
      }
    ), ie(
      () => m.value,
      () => {
        let A = m.value.map((w) => w.active && !w.disabled).lastIndexOf(!0);
        A < 0 && (f.value >= m.value.length ? A = m.value.map((w) => !w.disabled).lastIndexOf(!0) : m.value[f.value] && !m.value[f.value].disabled && (A = f.value)), A < 0 && (A = m.value.map((w) => !w.disabled).indexOf(!0)), m.value.forEach((w, O) => w.active = O === A), _(A);
      }
    ), de(() => {
      if (f.value < 0 && m.value.length > 0 && !m.value.some((A) => A.active)) {
        const A = m.value.map((w) => !w.disabled).indexOf(!0);
        _(A >= 0 ? A : -1);
      }
    }), Fe(Na, {
      lazy: v.value,
      card: l.value
    }), (A, w) => (c(), N(q(e.tag), {
      id: e.id,
      class: x(["tabs", o(z)])
    }, {
      default: L(() => [
        o(n) ? (c(), b("div", {
          key: 0,
          class: x(["tab-content", e.contentClass])
        }, [
          (c(!0), b(X, null, te(o(m), ({ tab: O, contentId: K, tabClasses: Z, active: Y }, R) => (c(), N(q(O), {
            key: R,
            id: K,
            class: x(Z),
            active: Y
          }, null, 8, ["id", "class", "active"]))), 128)),
          o(I) ? (c(), b("div", {
            key: "bv-empty-tab",
            class: x(["tab-pane active", { "card-body": o(l) }])
          }, [
            $(A.$slots, "empty")
          ], 2)) : P("", !0)
        ], 2)) : P("", !0),
        E("div", {
          class: x([e.navWrapperClass, { "card-header": o(l), "ms-auto": e.vertical && o(n) }])
        }, [
          E("ul", {
            class: x(["nav", [o(S), e.navClass]]),
            role: "tablist"
          }, [
            $(A.$slots, "tabs-start"),
            (c(!0), b(X, null, te(o(m), ({ tab: O, buttonId: K, contentId: Z, navItemClasses: Y, active: R, target: se }, re) => (c(), b("li", {
              key: re,
              class: x(["nav-item", O.props["title-item-class"]])
            }, [
              E("button", D({
                id: K,
                class: ["nav-link", Y],
                "data-bs-toggle": "tab",
                "data-bs-target": se,
                role: "tab",
                "aria-controls": Z,
                "aria-selected": R
              }, O.props["title-link-attributes"], {
                onClick: Et((J) => F(J, re), ["stop", "prevent"])
              }), [
                O.children && O.children.title ? (c(), N(q(O.children.title), { key: 0 })) : (c(), b(X, { key: 1 }, [
                  Q(H(O.props.title), 1)
                ], 64))
              ], 16, Lr)
            ], 2))), 128)),
            $(A.$slots, "tabs-end")
          ], 2)
        ], 2),
        o(n) ? P("", !0) : (c(), b("div", {
          key: 1,
          class: x(["tab-content", e.contentClass])
        }, [
          (c(!0), b(X, null, te(o(m), ({ tab: O, contentId: K, tabClasses: Z, active: Y }, R) => (c(), N(q(O), {
            key: R,
            id: K,
            class: x(Z),
            active: Y
          }, null, 8, ["id", "class", "active"]))), 128)),
          o(I) ? (c(), b("div", {
            key: "bv-empty-tab",
            class: x(["tab-pane active", { "card-body": o(l) }])
          }, [
            $(A.$slots, "empty")
          ], 2)) : P("", !0)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Er = /* @__PURE__ */ C({
  __name: "BTab",
  props: {
    id: null,
    title: null,
    active: { default: !1 },
    buttonId: { default: void 0 },
    disabled: { default: !1 },
    lazy: { default: !1 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, a = i(s(t, "active")), l = i(s(t, "disabled")), n = i(s(t, "lazy")), r = Be(Na, null), d = u(() => (r == null ? void 0 : r.lazy) || n.value), v = u(() => a.value && !l.value), g = u(() => v.value || !d.value), B = u(() => ({
      active: a.value,
      show: a.value,
      "card-body": (r == null ? void 0 : r.card) && t.noBody === !1
    }));
    return (y, h) => (c(), N(q(e.tag), {
      id: e.id,
      class: x(["tab-pane", o(B)]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: L(() => [
        o(g) ? $(y.$slots, "default", { key: 0 }) : P("", !0)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Hr = "toast-title", Lt = 1e3, qr = C({
  components: { BLink: be },
  props: {
    ...Ce,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String },
    body: { type: [Object, String] },
    headerClass: { type: String },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: !0 },
    id: { type: String },
    isStatus: { type: [Boolean, String], default: !1 },
    autoHide: { type: [Boolean, String], default: !0 },
    noCloseButton: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    solid: { type: [Boolean, String], default: !1 },
    static: { type: [Boolean, String], default: !1 },
    title: { type: String },
    modelValue: { type: [Boolean, String], default: !1 },
    toastClass: { type: Array },
    variant: { type: String }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: a }) {
    i(s(e, "animation"));
    const l = i(s(e, "isStatus")), n = i(s(e, "autoHide")), r = i(s(e, "noCloseButton")), d = i(s(e, "noFade")), v = i(s(e, "noHoverPause"));
    i(s(e, "solid")), i(s(e, "static"));
    const g = i(s(e, "modelValue")), B = G(!1), y = G(!1), h = G(!1), T = u(() => ({
      [`b-toast-${e.variant}`]: e.variant,
      show: h.value || B.value
    }));
    let V, k, p;
    const f = () => {
      typeof V > "u" || (clearTimeout(V), V = void 0);
    }, m = u(
      () => Math.max(xe(e.delay, 0), Lt)
    ), I = () => {
      g.value && (k = p = 0, f(), y.value = !0, qe(() => {
        h.value = !1;
      }));
    }, z = () => {
      f(), t("update:modelValue", !0), k = p = 0, y.value = !1, Se(() => {
        qe(() => {
          h.value = !0;
        });
      });
    }, S = () => {
      if (!n.value || v.value || !V || p)
        return;
      const Z = Date.now() - k;
      Z > 0 && (f(), p = Math.max(m.value - Z, Lt));
    }, _ = () => {
      (!n.value || v.value || !p) && (p = k = 0), F();
    };
    ie(
      () => g.value,
      (Z) => {
        Z ? z() : I();
      }
    );
    const F = () => {
      f(), n.value && (V = setTimeout(I, p || m.value), k = Date.now(), p = 0);
    }, j = () => {
      B.value = !0, t("update:modelValue", !0);
    }, A = () => {
      B.value = !1, F();
    }, w = () => {
      B.value = !0;
    }, O = () => {
      B.value = !1, p = k = 0, t("update:modelValue", !1);
    };
    al(() => {
      f(), n.value && t("destroyed", e.id);
    }), de(() => {
      Se(() => {
        g.value && qe(() => {
          z();
        });
      });
    });
    const K = () => {
      Se(() => {
        qe(() => {
          I();
        });
      });
    };
    return () => {
      const Z = () => {
        const Y = [], R = ve(Hr, { hide: I }, a);
        R ? Y.push(W(R)) : e.title && Y.push(W("strong", { class: "me-auto" }, e.title)), !r.value && Y.length !== 0 && Y.push(
          W(fa, {
            class: ["btn-close"],
            onClick: () => {
              I();
            }
          })
        );
        const se = [];
        if (Y.length > 0 && se.push(
          W(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => Y }
          )
        ), ve("default", { hide: I }, a) || e.body) {
          const re = W(
            ze(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: ze(e) ? { click: K } : {}
            },
            ve("default", { hide: I }, a) || e.body
          );
          se.push(re);
        }
        return W(
          "div",
          {
            class: ["toast", e.toastClass, T.value],
            tabindex: "0"
          },
          se
        );
      };
      return W(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: y.value ? null : l.value ? "status" : "alert",
          "aria-live": y.value ? null : l.value ? "polite" : "assertive",
          "aria-atomic": y.value ? null : "true",
          onmouseenter: S,
          onmouseleave: _
        },
        [
          W(
            Ue,
            {
              noFade: d.value,
              onAfterEnter: A,
              onBeforeEnter: j,
              onAfterLeave: O,
              onBeforeLeave: w
            },
            () => [h.value ? Z() : ""]
          )
        ]
      );
    };
  }
}), Rr = {
  BAccordion: Ul,
  BAccordionItem: Ql,
  BNavText: fi,
  BAlert: tn,
  BAvatar: on,
  BAvatarGroup: an,
  BNavForm: ti,
  BBadge: fn,
  BBreadcrumb: pn,
  BBreadcrumbItem: ca,
  BButton: Le,
  BButtonGroup: Bn,
  BButtonToolbar: kn,
  BCard: Vn,
  BCardBody: wn,
  BCardFooter: An,
  BCardGroup: xn,
  BCardHeader: In,
  BCardImg: On,
  BCardSubTitle: ba,
  BCardText: Pn,
  BCardTitle: va,
  BCarousel: Jn,
  BCarouselSlide: as,
  BCloseButton: fa,
  BCol: Ie,
  BCollapse: ua,
  BContainer: us,
  BDropdown: ha,
  BDropdownDivider: vs,
  BDropdownForm: hs,
  BDropdownGroup: ks,
  BDropdownHeader: Vs,
  BDropdownItem: As,
  BDropdownItemButton: Is,
  BDropdownText: Ps,
  BForm: ya,
  BFormCheckbox: Ba,
  BFormCheckboxGroup: Xs,
  BFormFloatingLabel: Rs,
  BFormGroup: ao,
  BFormInput: oo,
  BFormInvalidFeedback: ct,
  BFormRadio: ka,
  BFormRadioGroup: vo,
  BFormRow: je,
  BFormSelect: po,
  BFormSelectOption: yt,
  BFormSelectOptionGroup: Sa,
  BFormText: ft,
  BFormTextarea: Po,
  BFormTag: Ta,
  BFormTags: Oo,
  BFormValidFeedback: vt,
  BImg: Eo,
  BInputGroup: Go,
  BInputGroupAddon: Bt,
  BInputGroupAppend: Uo,
  BInputGroupPrepend: Wo,
  BInputGroupText: Ca,
  BLink: be,
  BListGroup: Xo,
  BListGroupItem: Ko,
  BModal: Qo,
  BNav: ei,
  BNavbar: vi,
  BNavbarBrand: gi,
  BNavbarNav: pi,
  BNavbarToggle: Ai,
  BNavItem: oi,
  BNavItemDropdown: ri,
  BOffcanvas: zi,
  BOverlay: Hi,
  BPagination: Xi,
  BPopover: er,
  BProgress: tr,
  BProgressBar: Fa,
  BRow: nr,
  BSkeleton: Me,
  BSkeletonIcon: sr,
  BSkeletonTable: rr,
  BSkeletonWrapper: ur,
  BSpinner: cr,
  BTab: Er,
  BTable: Cr,
  BTableSimple: Oa,
  BTbody: Vr,
  BTd: Ar,
  BTfoot: xr,
  BTh: Or,
  BThead: Nr,
  BTr: zr,
  BToast: qr,
  BToaster: dt,
  BToastContainer: dt,
  BTabs: Pr,
  BTransition: Ue,
  BToastPlugin: rs
};
const Gr = {
  install(e, t = {}) {
    Object.entries(Rr).forEach(([a, l]) => {
      e.component(a, l);
    }), Object.entries(wi).forEach(([a, l]) => {
      e.directive(a, l);
    }), dl(e);
  }
};
export {
  Ul as BAccordion,
  Ql as BAccordionItem,
  tn as BAlert,
  on as BAvatar,
  an as BAvatarGroup,
  fn as BBadge,
  pn as BBreadcrumb,
  ca as BBreadcrumbItem,
  Le as BButton,
  Bn as BButtonGroup,
  kn as BButtonToolbar,
  Vn as BCard,
  wn as BCardBody,
  An as BCardFooter,
  xn as BCardGroup,
  In as BCardHeader,
  On as BCardImg,
  ba as BCardSubTitle,
  Pn as BCardText,
  va as BCardTitle,
  Jn as BCarousel,
  as as BCarouselSlide,
  fa as BCloseButton,
  Ie as BCol,
  ua as BCollapse,
  us as BContainer,
  ha as BDropdown,
  vs as BDropdownDivider,
  hs as BDropdownForm,
  ks as BDropdownGroup,
  Vs as BDropdownHeader,
  As as BDropdownItem,
  Is as BDropdownItemButton,
  Ps as BDropdownText,
  ya as BForm,
  Ba as BFormCheckbox,
  Xs as BFormCheckboxGroup,
  Rs as BFormFloatingLabel,
  ao as BFormGroup,
  oo as BFormInput,
  ct as BFormInvalidFeedback,
  ka as BFormRadio,
  vo as BFormRadioGroup,
  je as BFormRow,
  po as BFormSelect,
  yt as BFormSelectOption,
  Sa as BFormSelectOptionGroup,
  Ta as BFormTag,
  Oo as BFormTags,
  ft as BFormText,
  Po as BFormTextarea,
  vt as BFormValidFeedback,
  Eo as BImg,
  Go as BInputGroup,
  Bt as BInputGroupAddon,
  Uo as BInputGroupAppend,
  Wo as BInputGroupPrepend,
  Ca as BInputGroupText,
  be as BLink,
  Xo as BListGroup,
  Ko as BListGroupItem,
  Qo as BModal,
  ei as BNav,
  ti as BNavForm,
  oi as BNavItem,
  ri as BNavItemDropdown,
  fi as BNavText,
  vi as BNavbar,
  gi as BNavbarBrand,
  pi as BNavbarNav,
  Ai as BNavbarToggle,
  zi as BOffcanvas,
  Hi as BOverlay,
  Xi as BPagination,
  er as BPopover,
  tr as BProgress,
  Fa as BProgressBar,
  nr as BRow,
  Me as BSkeleton,
  sr as BSkeletonIcon,
  rr as BSkeletonTable,
  ur as BSkeletonWrapper,
  cr as BSpinner,
  Er as BTab,
  Cr as BTable,
  Oa as BTableSimple,
  Pr as BTabs,
  Vr as BTbody,
  Ar as BTd,
  xr as BTfoot,
  Or as BTh,
  Nr as BThead,
  qr as BToast,
  dt as BToastContainer,
  rs as BToastPlugin,
  dt as BToaster,
  zr as BTr,
  Ue as BTransition,
  Gr as BootstrapVue3,
  Xe as BvEvent,
  yi as VBPopover,
  ht as VBToggle,
  Si as VBTooltip,
  Ti as VBVisible,
  Gr as default,
  cl as useBreadcrumb,
  pa as useToast
};
